var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Esta es la documentación técnica del programa wallter.exe Para mas detalles ver el archivo README.org o el archivo documentación.pdf. Developer Info Franterminator Programador de pequeños programas.","tags":"","loc":"index.html"},{"title":"main.f95 – Fortran Program","text":"Programs WALLTER Subroutines linea commandLine bienvenido datos constructMatriz constructVector fCholesky linearSystem analiticaNavier vectorToMatrix Source Code main.f95 Source Code !< author: francisco rivera alvarez !  Programa para el calculo de flechas de una placa apoyada !  en sus cantos con carga hidraulica hasta la mitad de su largo Program WALLTER real * 8 , dimension (:,:), allocatable :: matriz !! sistema de ecuaciones real * 8 , dimension (:), allocatable :: f !! vector terminos independientes real * 8 , dimension (:,:), allocatable :: navier !! vector terminos analiticos real * 8 , dimension (:,:), allocatable :: fMatriz !! solucion en forma matricial character ( len = 50 ) :: resultsFile = './result/' !! directorio donde se escribiran los resultados character ( len = 50 ) :: configFile = '' !! directorio donde se encuentran los config file logical :: asserts = . FALSE . !! si se activa se imprimen los datos de la factorizacion logical :: exists !! comprueba la existencia de los directorios de resultados real * 8 :: ancho , largo , espesor !! dimensiones de la placa real * 8 :: rigidez !! rigidez a flexion de la placa integer :: n , m !! numero de puntos para discretizar largo(n) y ancho(m) COMMON resultsFile , configFile !! variables globales ! comprueba si existe el directorio de resultados inquire ( file = resultsFile , exist = exists ) if (. NOT . exists ) resultsFile = 'resultados.html' ! si no existe crea el archivo al lado del programa if ( exists ) resultsFile = TRIM ( resultsFile ) // TRIM ( 'resultados.html' ) ! inicio del programa call commandLine ( asserts ) ! opciones de ejecucion call bienvenido () ! mensaje de bienvenida (header) call datos ( ancho , largo , espesor , rigidez , n , m ) ! datos para poder funcionar el programa allocate ( matriz ( n * m , n + 1 )) ! fija la matriz de resultados numericos call constructMatriz ( ancho , largo , matriz , n , m ) ! construye la matriz para los resultados numericos allocate ( f ( n * m )) ! fija el vector de resultados numericos call constructVector ( largo , rigidez , f , n , m ) ! construye el vector para los resultados numericos ! muestra la matriz y factorizacion if ( asserts ) then call printMatrix ( matriz , 'Matriz' ) ! imprime en pantalla la matriz call printVector ( f , 'Vector' ) ! imprime en pantallas el vector de terminos independientes ! factorizacion y resultados call fCholesky ( matriz , n , m ) ! factorizada la matriz por cholesky call printMatrix ( matriz , 'Matriz (factorizada)' ) ! resolucion del sistema call linearSystem ( matriz , f , n , m ) call linearSystem ( matriz , f , n , m ) ! muestra solo la solucion else ! factoriza y resuelve call fCholesky ( matriz , n , m ) call linearSystem ( matriz , f , n , m ) call linearSystem ( matriz , f , n , m ) end if ! cambio de vector a matriz solucion allocate ( fMatriz ( n , m )) call vectorToMatrix ( f , fMatriz , n , m ) call printMatrix ( fMatriz , 'Solucion numerica' ) call resNumericos ( ancho , largo , fMatriz , n , m ) ! calcula los resultados analiticos por Navier allocate ( navier ( n , m )) call analiticaNavier ( navier , ancho , largo , rigidez , n , m ) call printMatrix ( navier , 'Solucion analitica' ) call resAnaliticos ( ancho , largo , navier , n , m ) ! para que no se cierre el programa derepente write ( * , * ) \"Gracias por usar el programa...\" read ( * , * ) contains !< Imprime una linea, un texto centrado y una lï¿½nea. ! Creando como un titulo. subroutine header ( label ) character ( len =* ), intent ( in ) :: label character ( len = 30 ) :: formato character ( len = 2 ) :: iString integer :: i ! 30 is the line length / 2 i = 30 - len ( label ) / 2 write ( iString , '(i2)' ) i formato = '(' // iString // 'X,A)' call linea () write ( * , formato ) label call linea () end subroutine !< Imprime una matriz mas un texto como titulo. subroutine printMatrix ( matriz , label ) real * 8 , dimension (:,:), intent ( in ) :: matriz character ( len =* ), intent ( in ) :: label integer :: i , j call header ( label ) do i = 1 , ubound ( matriz , 1 ) write ( * , '(*(f0.4,5x))' ) ( matriz ( i , j ), j = 1 , ubound ( matriz , 2 )) end do call linea () end subroutine !< Imprime un vector mas un texto como titulo subroutine printVector ( f , label ) real * 8 , dimension (:), intent ( in ) :: f character ( len =* ), intent ( in ) :: label integer :: i call header ( label ) do i = 1 , ubound ( f , 1 ) write ( * , * ) f ( i ) end do call linea () end subroutine End Program WALLTER !< Imprime una lï¿½nea de 60 caracteres. !  Se usa para separar la informacion que se imprime en la pantalla subroutine linea () write ( * , * ) \"____________________________________________________________\" end subroutine !< Analiza los argumentos cuando se ejecuto el programa. !  -h -> help: imprime las opciones disponibles. !  -a -> asserts: activa la impresion de los datos de la factorizacion. subroutine commandLine ( asserts ) logical , intent ( out ) :: asserts !! cuando es verdadera se activa la impresion de los datos de factorizacion integer :: i !! numero de argumentos character ( len = 30 ) :: cmd !! el argumento que se analiza character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile i = iargc () if ( i > 0 ) then do i = 1 , iargc () call getarg ( i , cmd ) if ( cmd == '-h' ) then write ( * , * ) 'Las opciones disponibles son:' write ( * , * ) '-h para ver esta ayuda' write ( * , * ) '-a para activar la impresion de los datos de factorizacion' write ( * , * ) '-c [FILENAME] para usar un programa de configuracion con los datos' call exit ( 0 ) end if if ( cmd == '-a' ) then write ( * , * ) 'Se ha activado la impresion de los datos de factorizacion.' asserts = . TRUE . end if if ( cmd == '-c' ) then write ( * , * ) 'Se usara para los datos el siguiente config file: ' call getarg ( i + 1 , configFile ) write ( * , * ) configFile exit end if end do end if end subroutine !< Imprime un mensaje de bienvenida subroutine bienvenido () write ( * , * ) \"                                  ,--,      ,--,           ,----,                     \" write ( * , * ) \"                               ,---.'|   ,---.'|         ,/   .`|                     \" write ( * , * ) \"           .---.   ,---,       |   | :   |   | :       ,`   .'  :   ,---,.,-.----.    \" write ( * , * ) \"          /. ./|  '  .' \\      :   : |   :   : |     ;    ;     / ,'  .' |\\    /  \\   \" write ( * , * ) \"      .--'.  ' ; /  ;    '.    |   ' :   |   ' :   .'___,/    ,',---.'   |;   :    \\  \" write ( * , * ) \"     /__./ \\ : |:  :       \\   ;   ; '   ;   ; '   |    :     | |   |   .'|   | .\\ :  \" write ( * , * ) \" .--'.  '   \\' .:  |   /\\   \\  '   | |__ '   | |__ ;    |.';  ; :   :  |-,.   : |: |  \" write ( * , * ) \"/___/ \\ |    ' '|  :  ' ;.   : |   | :.'||   | :.'|`----'  |  | :   |  ;/||   |  \\ :  \" write ( * , * ) \";   \\  \\;      :|  |  ;/  \\   \\'   :    ;'   :    ;    '   :  ; |   :   .'|   : .  /  \" write ( * , * ) \" \\   ;  `      |'  :  | \\  \\ ,'|   |  ./ |   |  ./     |   |  ' |   |  |-,;   | |  \\  \" write ( * , * ) \"  .   \\    .\\  ;|  |  '  '--'  ;   : ;   ;   : ;       '   :  | '   :  ;/||   | ;\\  \\ \" write ( * , * ) \"   \\   \\   ' \\ ||  :  :        |   ,/    |   ,/        ;   |.'  |   |    \\:   ' | \\.' \" write ( * , * ) \"    :   '  |--' |  | ,'        '---'     '---'         '---'    |   :   .':   : :-'   \" write ( * , * ) \"     \\   \\ ;    `--''                                           |   | ,'  |   |.'     \" write ( * , * ) \"      '---'                                                     `----'    `---'       \" write ( * , * ) \"Bienvenido -------> \" write ( * , '(20X,A)' ) \"Pulse enter para continuar\" read ( * , * ) end subroutine !< Solicita los datos necesarios para el calculo de la flecha. subroutine datos ( ancho , largo , espesor , rigidez , n , m ) ! ------------- Variables ----------------- ! integer * 4 , intent ( out ) :: n , m !! numero de puntos para discretizar la placa real * 8 , intent ( out ) :: largo , ancho , espesor !! dimensiones de la placa real * 8 , intent ( out ) :: rigidez !! rigidez a flexion -> D = E*t&#94;3/(12(1-v&#94;2)) real * 8 :: Young !! Modulo de Young real * 8 :: poisson !! Coeficiente de Poisson logical :: exists = . FALSE . !! existe el archivo de configuracion? character ( len = 50 ) :: label !! etiquetas del archivo de configuracion real * 8 :: numero = 0 integer * 4 , dimension ( 7 ) :: modif = 0 integer :: i integer :: sel = 1 character ( len = 7 ), dimension ( 7 ) :: etiquetas = & ( / \"ancho  \" , \"largo  \" , \"espesor\" , \"n      \" , \"m      \" , \"Young  \" , \"poisson\" / ) integer * 4 :: ios = 0 character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile ! ************** Codigo ****************** ! ! comprueba que se haya definido un archivo de configuracion y de que existe if ( configFile /= '' ) then inquire ( file = configFile , exist = exists ) if (. NOT . exists ) then write ( * , * ) 'No se ha encontrado el archivo de configuracion.' end if end if ! si existe se abre y se lee la informacion if ( exists ) then open ( unit = 24 , file = configFile , status = 'old' , action = 'read' ) ! se abre ! se lee la informacion, quitando las etiquetas ! importante poner las etiquetas como en los archivos ejemplo do while ( ios >= 0 ) read ( 24 , * , iostat = ios ) label , numero ! check if there were problems reading the file if ( ios < 0 ) then continue end if ! check label reference if ( label == 'ancho::' ) then ancho = numero modif ( 1 ) = 1 end if if ( label == 'largo::' ) then largo = numero modif ( 2 ) = 1 end if if ( label == 'espesor::' ) then espesor = numero modif ( 3 ) = 1 end if if ( label == 'n::' ) then n = numero modif ( 4 ) = 1 end if if ( label == 'm::' ) then m = numero modif ( 5 ) = 1 end if if ( label == 'young::' ) then Young = numero modif ( 6 ) = 1 end if if ( label == 'poisson::' ) then poisson = numero modif ( 7 ) = 1 end if end do close ( 24 ) ! se imprime los datos obtenidos por si el usuario los quiere cambiar write ( * , * ) \"Datos config file ::\" write ( * , '(5X,A,f0.3,A,f0.3,A,f0.3)' ) \"Datos placa ->\" , ancho , \" x \" , largo , \" x \" , espesor write ( * , '(5X,A,i2,A,i2,A)' ) \"Datos discretizacion [n,m] -> [\" , n , \",\" , m , \"]\" write ( * , '(5X,A,f0.1,A,f0.3)' ) \"Datos material -> Young:: \" , Young , \"; poisson:: \" , poisson endif call linea () write ( * , * ) 'Se procede a pedir los datos al usuario que falten.' write ( * , * ) 'Si se equivoca en algun numero podra cambiarlo al final de programa.' do while ( sel == 1 ) ! Datos tecnicos de la placa if ( modif ( 1 ) == 0 . OR . modif ( 2 ) == 0 . OR . modif ( 3 ) == 0 ) then write ( * , * ) \"*************************\" write ( * , * ) \"*   DATOS DE LA PLACA   *\" write ( * , * ) \"*************************\" if ( modif ( 1 ) == 0 ) then write ( * , * ) \"-> ancho de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) ancho ; modif ( 1 ) = 1 end if if ( modif ( 2 ) == 0 ) then write ( * , * ) \"-> largo de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) largo ; modif ( 2 ) = 1 end if if ( modif ( 3 ) == 0 ) then write ( * , * ) \"-> espesor de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) espesor ; modif ( 3 ) = 1 end if end if ! datos para la discretizacion del modelo if ( modif ( 4 ) == 0 . OR . modif ( 5 ) == 0 ) then write ( * , * ) \"*************************\" write ( * , * ) \"*   NUMERO DE PUNTOS    *\" write ( * , * ) \"*************************\" if ( modif ( 4 ) == 0 ) then write ( * , * ) \"-> puntos para discretizar el largo\" write ( * , '(A,$)' ) \"(integer) \" read ( * , * ) n ; modif ( 4 ) = 1 endif if ( modif ( 5 ) == 0 ) then write ( * , * ) \"-> puntos para discretizar el ancho\" write ( * , '(A,$)' ) \"(integer) \" read ( * , * ) m ; modif ( 5 ) = 1 endif endif ! propiedades del material if ( modif ( 6 ) == 0 . OR . modif ( 7 ) == 0 ) then write ( * , * ) \"*************************\" write ( * , * ) \"*   DATOS DEL MATERIAL  *\" write ( * , * ) \"*************************\" if ( modif ( 6 ) == 0 ) then write ( * , * ) \"-> Modulo de Young\" write ( * , '(A,$)' ) \"(MPa) \" read ( * , * ) Young ; modif ( 6 ) = 1 endif if ( modif ( 7 ) == 0 ) then write ( * , * ) \"-> Coef. de poisson\" write ( * , '(A,$)' ) \"(_real_) \" read ( * , * ) poisson ; modif ( 7 ) = 1 endif endif ! cambiar valores si se han introducido valores a mano ! si hay un archivo se entiende que el usuario no tiene ! la necesidad de cambiar ningun dato. if (. NOT . exists ) then call linea () write ( * , * ) \"Desea cambiar algun valor:\" write ( * , * ) \"1) Si\" write ( * , * ) \"2) No\" read ( * , * ) sel if ( sel == 1 ) then write ( * , \"(5X,A)\" ) \"Que valor desea cambiar?\" do i = 1 , 7 write ( * , \"(10X,I2,A,A)\" ) i , \") \" , etiquetas ( i ) end do read ( * , * ) i modif ( i ) = 0 end if else sel = 20 end if end do ! MPa (N/mm3) -> 1000 KPa (kN/m2) rigidez = Young * 1000 * espesor ** 3 rigidez = rigidez / ( 12 * ( 1 - poisson ** 2 )) ! EXPORT HTML call createHTML ( \"resultados\" ) call exportMaterial ( Young , poisson ) call exportPlaca ( largo , ancho , espesor ) end subroutine !< Calculo los terminos de la matriz de resultados numericos y !  los coloca en su sitio. La matriz se almacena en banda. subroutine constructMatriz ( ancho , largo , matriz , n , m ) ! ------------- Variables ----------------- ! real * 8 , dimension ( n * m , n + 1 ), intent ( inout ) :: matriz real * 8 , intent ( in ) :: ancho , largo integer , intent ( in ) :: n , m real * 8 :: A , B , C , deltaX , deltaY integer :: i ! calculo de los coef A, B y C deltaX = ancho / ( m + 1 ) deltaY = largo / ( n + 1 ) B = 1 / ( deltaX ** 2 ) C = 1 / ( deltaY ** 2 ) A = - 2 * ( B + C ) write ( * , '(A,3(f0.2,X),A)' ) \"[A,B,C] -> [ \" , A , B , C , \"]\" !matriz y vector a cero matriz (:,:) = 0 ! construccion matriz do i = 1 , n * m matriz ( i , 1 ) = A if ( mod ( i , n ) == 0 . AND . i > 1 ) then matriz ( i , 2 ) = 0 else matriz ( i , 2 ) = B end if if ( i + n <= n * m ) matriz ( i , n + 1 ) = C end do end subroutine !< Construye el vector de resultados numericos subroutine constructVector ( largo , rigidez , vector , n , m ) ! ------------- Variables ----------------- ! real * 8 , dimension ( n * m ), intent ( inout ) :: vector real * 8 , intent ( in ) :: largo , rigidez integer , intent ( in ) :: n , m integer :: i , j , t real * 8 :: deltaY , presion ! vector a cero vector (:) = 0 deltaY = largo / ( n + 1 ) ! construccion vector t = 1 do j = 1 , m do i = 1 , n ! peso especifico agua = 10000 N / m3 -> 10 kN / m3 presion = 10 * ( largo / 2 - i * deltaY ) / rigidez !solo hasta la mitad if ( presion > 0 . AND . mod ( t - 1 , n ) == 0 ) then vector ( t ) = presion end if t = t + 1 end do end do end subroutine !< Factorizaciï¿½n de Cholesky -> A = L * D * Transpose[L] subroutine fCholesky ( matriz , n , m ) ! ------------- Variables ----------------- ! real * 8 , dimension ( n * m , n + 1 ), intent ( inout ) :: matriz integer :: k , i , j real * 8 :: suma ! factorizacion de cholesky do k = 1 , n * m - 1 do i = k + 1 - n + 1 , k if ( i < 1 ) cycle suma = 0 do j = MAX ( i - n , k + 1 - n ), i - 1 if ( j < 1 ) cycle suma = suma + matriz ( j , i - j + 1 ) * matriz ( j , k + 2 - j ) end do matriz ( i , k + 2 - i ) = ( matriz ( i , k + 2 - i ) - suma ) end do do i = k + 1 - n , k if ( i < 1 ) cycle matriz ( i , k + 2 - i ) = matriz ( i , k + 2 - i ) / matriz ( i , 1 ) end do suma = 0 do j = k + 1 - n , k if ( j < 1 ) cycle suma = suma + matriz ( j , k + 2 - j ) * matriz ( j , 1 ) * matriz ( j , k + 2 - j ) end do matriz ( k + 1 , 1 ) = matriz ( k + 1 , 1 ) - suma end do end subroutine !< Resolucion del sistema de ecuaciones para una matriz en banda factorizada subroutine linearSystem ( matriz , f , n , m ) ! ------------- Variables ----------------- ! real * 8 , dimension ( n * m , n * m ), intent ( inout ) :: matriz real * 8 , dimension ( n * m ), intent ( inout ) :: f integer , intent ( in ) :: n , m integer :: i , j real * 8 :: suma = 0 do i = 2 , n * m suma = 0 do j = i - n , i - 1 if ( j < 1 ) cycle suma = suma + matriz ( j , i - j + 1 ) * f ( j ) end do f ( i ) = f ( i ) - suma end do do i = 1 , n * m f ( i ) = f ( i ) / matriz ( i , 1 ) end do do i = n * m , 2 , - 1 do j = i - n , i - 1 if ( j < 1 ) cycle f ( j ) = f ( j ) - matriz ( j , i - j + 1 ) * f ( i ) end do end do end subroutine !< Resolucion del sistema mediante el metodo de Navier subroutine analiticaNavier ( w , ancho , largo , rigidez , n , m ) ! ------------- Variables ----------------- ! real * 8 , intent ( in ) :: ancho , largo real * 8 , intent ( in ) :: rigidez real * 8 , dimension ( n , m ), intent ( out ) :: w integer , intent ( in ) :: n , m integer :: i , j , r , s integer :: k , u real * 8 :: deltaX , deltaY , X , Y real * 8 :: p_ku , w_ku real * 8 :: pi = acos ( - 1.0 d0 ) integer , dimension ( 2 ) :: modif = 0 integer :: sel = 1 integer :: h logical :: exists = . FALSE . !! existe el archivo de configuracion? character ( len = 50 ) :: label !! etiquetas del archivo de configuracion real * 8 :: numero integer :: ios character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile ! ************** Codigo ****************** ! ! comprueba que se haya definido un archivo de configuracion y de que existe if ( configFile /= '' ) then inquire ( file = configFile , exist = exists ) if (. NOT . exists ) then write ( * , * ) 'No se ha encontrado el archivo de configuracion.' write ( * , * ) end if end if if ( exists ) then open ( unit = 24 , file = configFile , status = 'old' , action = 'read' ) ! se abre do while ( ios >= 0 ) read ( 24 , * , iostat = ios ) label , numero ! check if there were problems reading the file if ( ios < 0 ) then write ( * , * ) \"Fin de archivo\" continue end if ! check label reference if ( label == 'r::' ) then r = numero modif ( 1 ) = 1 end if if ( label == 's::' ) then s = numero modif ( 2 ) = 1 end if end do close ( 24 ) write ( * , * ) \"Los datos de \" , configFile , \" son:\" write ( * , '(A,I4,I4,A)' ) \"Numero de iteraciones para el calculo analitico -> [r,s] = [\" , r , s , \"]\" end if do while ( sel == 1 ) ! datos para el bucle de calculo de flecha if ( modif ( 1 ) == 0 . OR . modif ( 2 ) == 0 ) then write ( * , * ) \"*************************\" write ( * , * ) \"* NUMERO DE ITERACIONES *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> Numero de iteraciones para el calculo analitico: \" if ( modif ( 1 ) == 0 ) then write ( * , '(A,$)' ) 'r (interger): ' read ( * , * ) r ; modif ( 1 ) = 1 end if if ( modif ( 2 ) == 0 ) then write ( * , '(A,$)' ) 's (interger): ' read ( * , * ) s ; modif ( 2 ) = 1 end if end if ! cambiar valores si se han introducido valores a mano ! si hay un archivo se entiende que el usuario no tiene ! la necesidad de cambiar ningun dato. if (. NOT . exists ) then call linea () write ( * , * ) \"Desea cambiar algun valor:\" write ( * , * ) \"1) Si\" write ( * , * ) \"2) No\" read ( * , * ) sel if ( sel == 1 ) then write ( * , \"(5X,A)\" ) \"Que valor desea cambiar?\" write ( * , \"(10X,A)\" ) \"1) r\" write ( * , \"(10X,A)\" ) \"2) s\" read ( * , * ) h modif ( h ) = 0 end if else sel = 20 end if end do !calculamos deltaX y deltaY deltaX = ancho / ( m + 1 ) deltaY = largo / ( n + 1 ) ! ceros en w w (:,:) = 0 !bucle para cada x e y do j = 1 , m X = j * deltaX do i = 1 , n Y = i * deltaY !bucle para el calculo de la flecha do k = 1 , r do u = 1 , s p_ku = 4 * largo * 10 * sin ( k * pi / 2 ) ** 2 / ( k * u ** 2 * pi ** 3 ) p_ku = p_ku * ( u * pi - 2 * sin ( u * pi / 2 )) w_ku = ( k ** 2 / ancho ** 2 + u ** 2 / largo ** 2 ) w_ku = w_ku ** 2 w_ku = p_ku / ( pi ** 4 * rigidez * w_ku ) w ( i , j ) = w ( i , j ) + w_ku * sin ( k * pi * X / ancho ) * sin ( u * pi * Y / largo ) end do end do end do end do end subroutine !< Convierte el vector soluciÃ³n en matriz subroutine vectorToMatrix ( vector , matrix , n , m ) real * 8 , dimension ( n * m ), intent ( in ) :: vector real * 8 , dimension ( n , m ), intent ( out ) :: matrix integer :: i , j , t ! llena la matriz con ceros matrix (:,:) = 0 ! coloca los elementos del vector en la correcta posicion en la matriz t = 1 ! posicion en el vector do j = 1 , m do i = 1 , n matrix ( i , j ) = vector ( t ) t = t + 1 end do end do end subroutine","tags":"","loc":"sourcefile/main.f95.html"},{"title":"result.f95 – Fortran Program","text":"Subroutines createHTML exportMaterial exportPlaca resNumericos resAnaliticos Source Code result.f95 Source Code !< Crea el head y el principio del body del html de resultados ! para una mejor visualizacion del html, se recomienda crearlo7 ! en la carpeta result. Por defecto el programa lo hara asi. subroutine createHTML ( name ) character ( len =* ), intent ( in ) :: name character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile ) write ( 12 , '(A,$)' ) '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"' write ( 12 , * ) '\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">' write ( 12 , * ) '<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">' write ( 12 , * ) '<head>' write ( 12 , '(5X,3A)' ) '<title>' , name , '</title>' write ( 12 , '(5X,A)' ) '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />' write ( 12 , '(5X,A)' ) '<meta name=\"description\" content=\"\" />' write ( 12 , '(5X,A)' ) '<meta name=\"keywords\" content=\"\" />' write ( 12 , '(5X,A)' ) '<meta name=\"robots\" content=\"index,follow\" />' write ( 12 , '(5X,A)' ) '<link rel=\"stylesheet\" type=\"text/css\" href=\"./css/style.css\" />' write ( 12 , '(5X,A)' ) '<script src=\"https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.2.1.min.js\">' write ( 12 , '(5X,A)' ) '</script>' write ( 12 , '(5X,A)' ) '<script src=\"https://cdn.jsdelivr.net/clipboard.js/1.6.0/clipboard.min.js\">' write ( 12 , '(5X,A)' ) '</script>' write ( 12 , * ) '</head>' write ( 12 , * ) '<body>' write ( 12 , '(5X,A)' ) '<div class=\"row\">' write ( 12 , '(10X,A)' ) '<div class=\"header\">' write ( 12 , '(15X,A)' ) '<h1> Resultados del programa </h1>' write ( 12 , '(15X,A)' ) '<button id=\"bNumerico\">Resultados Numericos</button>' write ( 12 , '(15X,A)' ) '<button id=\"bAnalitico\">Resultados Analiticos</button>' write ( 12 , '(10X,A)' ) '</div>' write ( 12 , '(5X,A)' ) '</div>' close ( 12 ) end subroutine !< Escribe en la table de materiales en el html de resultados subroutine exportMaterial ( Young , poisson ) real * 8 , intent ( in ) :: Young , poisson character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(5X,A)' ) '<div class=\"row\">' write ( 12 , '(10X,A)' ) '<div class=\"box-item\">' write ( 12 , '(15X,A)' ) '<header> Material </header>' write ( 12 , '(15X,A)' ) '<p> El material empleado es : \t</p>' write ( 12 , '(15X,A)' ) '<table>' write ( 12 , '(20X,A,F0.3,A)' ) '<tr><td>E = ' , Young , ' MPa</td></tr>' write ( 12 , '(20X,A,F4.3,A)' ) '<tr><td>v = ' , poisson , '</td></tr>' write ( 12 , '(15X,A)' ) '</table>' close ( 12 ) end subroutine !< Escribe la table de datos de placa en el html de resultados subroutine exportPlaca ( largo , ancho , espesor ) real * 8 , intent ( in ) :: largo , ancho , espesor character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(15X,A)' ) '<header> Placa </header>' write ( 12 , '(15X,A)' ) '<p>Las medidas de la placa son:</p>' write ( 12 , '(15X,A)' ) '<table>' write ( 12 , '(20X,A,F6.3,A)' ) '<tr><td>Largo = ' , largo , ' m</td></tr>' write ( 12 , '(20X,A,F6.3,A)' ) '<tr><td>Ancho = ' , ancho , ' m</td></tr>' write ( 12 , '(20X,A,F4.3,A)' ) '<tr><td>Espesor = ' , espesor , ' m</td></tr>' write ( 12 , '(15X,A)' ) '</table>' write ( 12 , '(10X,A)' ) '</div>' close ( 12 ) end subroutine !< Escribe la table de resultados numericos en el html de resultados subroutine resNumericos ( ancho , largo , fMatriz , n , m ) real * 8 , dimension ( n , m ), intent ( in ) :: fMatriz real * 8 , intent ( in ) :: ancho , largo integer , intent ( in ) :: n , m real * 8 :: deltaX , deltaY character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile deltaX = ancho / ( m + 1 ) deltaY = largo / ( n + 1 ) open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(10X,A)' ) '<div class=\"box-item\" id=\"resultados\">' write ( 12 , '(15X,A)' ) '<header id=\"azul\"> Resultados </header>' write ( 12 , '(15X,A)' ) '<table id=\"tNumerico\">' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I5,A)' ) '<td rowspan=\"' , m + 2 , '\"> Y </th>' write ( 12 , '(20X,A)' ) '</tr>' do i = n , 1 , - 1 write ( 12 , '(20X,A)' ) '<tr>' write ( 12 , '(25X,A,F0.3,A)' ) '<td class=\"td-h\">' , i * deltaY , '</td>' write ( 12 , '(25X,*(A,f0.4,A))' ) ( '<td>' , fMatriz ( i , j ), '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' end do write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A)' ) '<td>/</td>' write ( 12 , '(25X,*(A,F0.3,A))' ) ( '<td>' , j * deltaX , '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I4,A)' ) '<td>O</td><td colspan=\"' , m + 1 , '\">X</td>' write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(15X,A)' ) '</table>' close ( 12 ) end subroutine !< Escribe la table de resultados analiticos en el html de resultados subroutine resAnaliticos ( ancho , largo , navier , n , m ) real * 8 , dimension ( n , m ), intent ( in ) :: navier real * 8 , intent ( in ) :: ancho , largo integer , intent ( in ) :: n , m real * 8 :: deltaX , deltaY character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile deltaX = ancho / ( m + 1 ) deltaY = largo / ( n + 1 ) open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(15X,A)' ) '<table id=\"tAnalitico\">' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I5,A)' ) '<td rowspan=\"' , m + 2 , '\"> Y </th>' write ( 12 , '(20X,A)' ) '</tr>' do i = n , 1 , - 1 write ( 12 , '(20X,A)' ) '<tr>' write ( 12 , '(25X,A,F0.3,A)' ) '<td class=\"td-h\">' , i * deltaY , '</td>' write ( 12 , '(25X,*(A,f0.4,A))' ) ( '<td>' , navier ( i , j ), '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' end do write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A)' ) '<td>/</td>' write ( 12 , '(25X,*(A,F0.3,A))' ) ( '<td>' , j * deltaX , '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I4,A)' ) '<td>O</td><td colspan=\"' , m + 1 , '\">X</td>' write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(15X,A)' ) '</table>' write ( 12 , '(10X,A)' ) '<button id=\"copyButton\" data-clipboard-action=\"copy\" data-clipboard-target=\".active\">' write ( 12 , '(15X,A)' ) 'Copia la tabla</button>' write ( 12 , '(10X,A)' ) '</div>' write ( 12 , '(5X,A)' ) '</div>' write ( 12 , '(5X,A)' ) '<script src=\"js/buttons.js\"></script>' write ( 12 , * ) '</body>' write ( 12 , * ) '</html>' close ( 12 ) end subroutine","tags":"","loc":"sourcefile/result.f95.html"},{"title":"compile.sh – Fortran Program","text":"Source Code compile.sh Source Code gfortran result.f95 main.f95 -o2 -o wallter.exe","tags":"","loc":"sourcefile/compile.sh.html"},{"title":"execute.sh – Fortran Program","text":"/bin/bash Source Code execute.sh Source Code #!/bin/bash i = 0 PS3 = 'Por facor escoga el modo de ejecuccion: ' options =( \"Por defecto\" \"Imprimir resultados factorizacion\" \"Escoger archivo de configuracion\" \"Salir\" ) select opt in \" ${ options [@] } \" do case $opt in \"Por defecto\" ) echo \"Ha escogido escoger el programa con las opciones por defecto.\" ./wallter.exe ;; \"Imprimir resultados factorizacion\" ) echo \"Ha escogido imprimir los resultados de la factorizacion.\" ./wallter.exe -a ;; \"Escoger archivo de configuracion\" ) echo \"Escoga el archivo de configuracion de la carpeta config que desee:\" for file in ./config/*.txt ; do (( i+ = 1 )) names [ i ]= \"./config/ ${ file ##*/ } \" echo \" $i ) ${ names [i] } \" done read sel ./wallter.exe -c ${ names [ $sel ] } ;; \"Salir\" ) break ;; * ) echo invalid option ;; esac done","tags":"","loc":"sourcefile/execute.sh.html"},{"title":"linea – Fortran Program","text":"subroutine linea() Imprime una lï¿½nea de 60 caracteres.\n  Se usa para separar la informacion que se imprime en la pantalla Arguments None Called By proc~~linea~~CalledByGraph proc~linea linea proc~printmatrix printMatrix proc~printmatrix->proc~linea proc~header header proc~printmatrix->proc~header proc~datos datos proc~datos->proc~linea proc~analiticanavier analiticaNavier proc~analiticanavier->proc~linea proc~header->proc~linea proc~printvector printVector proc~printvector->proc~linea proc~printvector->proc~header program~wallter WALLTER program~wallter->proc~printmatrix program~wallter->proc~datos program~wallter->proc~analiticanavier program~wallter->proc~printvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linea.html"},{"title":"commandLine – Fortran Program","text":"subroutine commandLine(asserts) Analiza los argumentos cuando se ejecuto el programa.\n  -h -> help: imprime las opciones disponibles.\n  -a -> asserts: activa la impresion de los datos de la factorizacion. Arguments Type Intent Optional Attributes Name logical, intent(out) :: asserts cuando es verdadera se activa la impresion de los datos de factorizacion Called By proc~~commandline~~CalledByGraph proc~commandline commandLine program~wallter WALLTER program~wallter->proc~commandline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/commandline.html"},{"title":"bienvenido – Fortran Program","text":"subroutine bienvenido() Imprime un mensaje de bienvenida Arguments None Called By proc~~bienvenido~~CalledByGraph proc~bienvenido bienvenido program~wallter WALLTER program~wallter->proc~bienvenido Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/bienvenido.html"},{"title":"datos – Fortran Program","text":"subroutine datos(ancho, largo, espesor, rigidez, n, m) Solicita los datos necesarios para el calculo de la flecha. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: ancho dimensiones de la placa real(kind=8), intent(out) :: largo dimensiones de la placa real(kind=8), intent(out) :: espesor dimensiones de la placa real(kind=8), intent(out) :: rigidez rigidez a flexion -> D = E*t&#94;3/(12(1-v&#94;2)) integer(kind=4), intent(out) :: n numero de puntos para discretizar la placa integer(kind=4), intent(out) :: m numero de puntos para discretizar la placa Calls proc~~datos~~CallsGraph proc~datos datos proc~exportplaca exportPlaca proc~datos->proc~exportplaca proc~linea linea proc~datos->proc~linea proc~exportmaterial exportMaterial proc~datos->proc~exportmaterial proc~createhtml createHTML proc~datos->proc~createhtml Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~datos~~CalledByGraph proc~datos datos program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/datos.html"},{"title":"constructMatriz – Fortran Program","text":"subroutine constructMatriz(ancho, largo, matriz, n, m) Calculo los terminos de la matriz de resultados numericos y\n  los coloca en su sitio. La matriz se almacena en banda. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(inout), dimension(n*m,n+1) :: matriz integer, intent(in) :: n integer, intent(in) :: m Called By proc~~constructmatriz~~CalledByGraph proc~constructmatriz constructMatriz program~wallter WALLTER program~wallter->proc~constructmatriz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/constructmatriz.html"},{"title":"constructVector – Fortran Program","text":"subroutine constructVector(largo, rigidez, vector, n, m) Construye el vector de resultados numericos Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: rigidez real(kind=8), intent(inout), dimension(n*m) :: vector integer, intent(in) :: n integer, intent(in) :: m Called By proc~~constructvector~~CalledByGraph proc~constructvector constructVector program~wallter WALLTER program~wallter->proc~constructvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/constructvector.html"},{"title":"fCholesky – Fortran Program","text":"subroutine fCholesky(matriz, n, m) Factorizaciï¿½n de Cholesky -> A = L * D * Transpose[L] Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(n*m,n+1) :: matriz integer :: n integer :: m Called By proc~~fcholesky~~CalledByGraph proc~fcholesky fCholesky program~wallter WALLTER program~wallter->proc~fcholesky Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fcholesky.html"},{"title":"linearSystem – Fortran Program","text":"subroutine linearSystem(matriz, f, n, m) Resolucion del sistema de ecuaciones para una matriz en banda factorizada Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(n*m,n*m) :: matriz real(kind=8), intent(inout), dimension(n*m) :: f integer, intent(in) :: n integer, intent(in) :: m Called By proc~~linearsystem~~CalledByGraph proc~linearsystem linearSystem program~wallter WALLTER program~wallter->proc~linearsystem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linearsystem.html"},{"title":"analiticaNavier – Fortran Program","text":"subroutine analiticaNavier(w, ancho, largo, rigidez, n, m) Resolucion del sistema mediante el metodo de Navier Arguments Type Intent Optional Attributes Name real(kind=8), intent(out), dimension(n,m) :: w real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: rigidez integer, intent(in) :: n integer, intent(in) :: m Calls proc~~analiticanavier~~CallsGraph proc~analiticanavier analiticaNavier proc~linea linea proc~analiticanavier->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~analiticanavier~~CalledByGraph proc~analiticanavier analiticaNavier program~wallter WALLTER program~wallter->proc~analiticanavier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/analiticanavier.html"},{"title":"vectorToMatrix – Fortran Program","text":"subroutine vectorToMatrix(vector, matrix, n, m) Convierte el vector soluciÃ³n en matriz Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(n*m) :: vector real(kind=8), intent(out), dimension(n,m) :: matrix integer :: n integer :: m Called By proc~~vectortomatrix~~CalledByGraph proc~vectortomatrix vectorToMatrix program~wallter WALLTER program~wallter->proc~vectortomatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/vectortomatrix.html"},{"title":"createHTML – Fortran Program","text":"subroutine createHTML(name) Crea el head y el principio del body del html de resultados\n para una mejor visualizacion del html, se recomienda crearlo7\n en la carpeta result. Por defecto el programa lo hara asi. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Called By proc~~createhtml~~CalledByGraph proc~createhtml createHTML proc~datos datos proc~datos->proc~createhtml program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/createhtml.html"},{"title":"exportMaterial – Fortran Program","text":"subroutine exportMaterial(Young, poisson) Escribe en la table de materiales en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Young real(kind=8), intent(in) :: poisson Called By proc~~exportmaterial~~CalledByGraph proc~exportmaterial exportMaterial proc~datos datos proc~datos->proc~exportmaterial program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportmaterial.html"},{"title":"exportPlaca – Fortran Program","text":"subroutine exportPlaca(largo, ancho, espesor) Escribe la table de datos de placa en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: espesor Called By proc~~exportplaca~~CalledByGraph proc~exportplaca exportPlaca proc~datos datos proc~datos->proc~exportplaca program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportplaca.html"},{"title":"resNumericos – Fortran Program","text":"subroutine resNumericos(ancho, largo, fMatriz, n, m) Escribe la table de resultados numericos en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in), dimension(n,m) :: fMatriz integer, intent(in) :: n integer, intent(in) :: m Called By proc~~resnumericos~~CalledByGraph proc~resnumericos resNumericos program~wallter WALLTER program~wallter->proc~resnumericos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/resnumericos.html"},{"title":"resAnaliticos – Fortran Program","text":"subroutine resAnaliticos(ancho, largo, navier, n, m) Escribe la table de resultados analiticos en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in), dimension(n,m) :: navier integer, intent(in) :: n integer, intent(in) :: m Called By proc~~resanaliticos~~CalledByGraph proc~resanaliticos resAnaliticos program~wallter WALLTER program~wallter->proc~resanaliticos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/resanaliticos.html"},{"title":"header – Fortran Program","text":"subroutine header(label) Imprime una linea, un texto centrado y una lï¿½nea.\n Creando como un titulo. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Calls proc~~header~~CallsGraph proc~header header proc~linea linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~header~~CalledByGraph proc~header header proc~printmatrix printMatrix proc~printmatrix->proc~header proc~printvector printVector proc~printvector->proc~header program~wallter WALLTER program~wallter->proc~printmatrix program~wallter->proc~printvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/header.html"},{"title":"printMatrix – Fortran Program","text":"subroutine printMatrix(matriz, label) Imprime una matriz mas un texto como titulo. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: matriz character(len=*), intent(in) :: label Calls proc~~printmatrix~~CallsGraph proc~printmatrix printMatrix proc~header header proc~printmatrix->proc~header proc~linea linea proc~printmatrix->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~printmatrix~~CalledByGraph proc~printmatrix printMatrix program~wallter WALLTER program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/printmatrix.html"},{"title":"printVector – Fortran Program","text":"subroutine printVector(f, label) Imprime un vector mas un texto como titulo Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: f character(len=*), intent(in) :: label Calls proc~~printvector~~CallsGraph proc~printvector printVector proc~header header proc~printvector->proc~header proc~linea linea proc~printvector->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~printvector~~CalledByGraph proc~printvector printVector program~wallter WALLTER program~wallter->proc~printvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/printvector.html"},{"title":"WALLTER – Fortran Program","text":"Programa para el calculo de flechas de una placa apoyada\n  en sus cantos con carga hidraulica hasta la mitad de su largo Calls program~~wallter~~CallsGraph program~wallter WALLTER proc~printmatrix printMatrix program~wallter->proc~printmatrix proc~commandline commandLine program~wallter->proc~commandline proc~datos datos program~wallter->proc~datos proc~resanaliticos resAnaliticos program~wallter->proc~resanaliticos proc~resnumericos resNumericos program~wallter->proc~resnumericos proc~analiticanavier analiticaNavier program~wallter->proc~analiticanavier proc~constructvector constructVector program~wallter->proc~constructvector proc~vectortomatrix vectorToMatrix program~wallter->proc~vectortomatrix proc~bienvenido bienvenido program~wallter->proc~bienvenido proc~constructmatriz constructMatriz program~wallter->proc~constructmatriz proc~linearsystem linearSystem program~wallter->proc~linearsystem proc~printvector printVector program~wallter->proc~printvector proc~fcholesky fCholesky program~wallter->proc~fcholesky proc~header header proc~printmatrix->proc~header proc~linea linea proc~printmatrix->proc~linea proc~datos->proc~linea proc~exportplaca exportPlaca proc~datos->proc~exportplaca proc~exportmaterial exportMaterial proc~datos->proc~exportmaterial proc~createhtml createHTML proc~datos->proc~createhtml proc~analiticanavier->proc~linea proc~printvector->proc~header proc~printvector->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Variables matriz f navier fMatriz resultsFile configFile asserts exists ancho largo espesor rigidez n m Subroutines header printMatrix printVector Common Blocks common variables globales Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n       $('[data-toggle=\"popover\"]').popover()\n       }) Variables Type Attributes Name Initial real(kind=8), dimension(:,:), allocatable :: matriz sistema de ecuaciones real(kind=8), dimension(:), allocatable :: f vector terminos independientes real(kind=8), dimension(:,:), allocatable :: navier vector terminos analiticos real(kind=8), dimension(:,:), allocatable :: fMatriz solucion en forma matricial character(len=50) :: resultsFile = './result/' directorio donde se escribiran los resultados character(len=50) :: configFile = '' directorio donde se encuentran los config file logical :: asserts = .FALSE. si se activa se imprimen los datos de la factorizacion logical :: exists comprueba la existencia de los directorios de resultados real(kind=8) :: ancho dimensiones de la placa real(kind=8) :: largo dimensiones de la placa real(kind=8) :: espesor dimensiones de la placa real(kind=8) :: rigidez rigidez a flexion de la placa integer :: n numero de puntos para discretizar largo(n) y ancho(m) integer :: m numero de puntos para discretizar largo(n) y ancho(m) Subroutines subroutine header (label) Imprime una linea, un texto centrado y una lï¿½nea.\n Creando como un titulo. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label subroutine printMatrix (matriz, label) Imprime una matriz mas un texto como titulo. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: matriz character(len=*), intent(in) :: label subroutine printVector (f, label) Imprime un vector mas un texto como titulo Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: f character(len=*), intent(in) :: label","tags":"","loc":"program/wallter.html"}]}