var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is . This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. [[linalg]] Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like  y = x&#94;2  or math on its own line\nlike  x = \\sqrt{y}  or  e = mc&#94;2.  You can even use LaTeX environments!\nSo you can get numbered equations like this:\n\\begin{equation}\n  PV = nRT\n\\end{equation}\nSo let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info Franterminator I program stuff in Fortran.","tags":"","loc":"index.html"},{"title":"main.f95 – Fortran Program","text":"Programs WALLTER Subroutines linea commandLine bienvenido datos constructMatriz constructVector fCholesky linearSystem analiticaNavier Source Code main.f95 Source Code !< author: francisco rivera alvarez !  Programa para el calculo de flechas de una placa apoyada !  en sus cantos con carga hidraulica hasta la mitad de su largo Program WALLTER real * 8 , dimension (:,:), allocatable :: matriz !! sistema de ecuaciones real * 8 , dimension (:), allocatable :: f !! vector terminos independientes real * 8 , dimension (:,:), allocatable :: navier !! vector terminos analiticos real * 8 , dimension (:,:), allocatable :: fMatriz !! solucion en forma matricial integer , dimension ( 2 ) :: forma !! forma de la matriz solucion integer , dimension ( 2 ) :: orden = ( / 2 , 1 / ) !! orden de los numeros al cambiar vector a matriz solucion character ( len = 50 ) :: resultsFile = './result/resultados.html' !! directorio donde se escribiran los resultados character ( len = 50 ) :: configFile = '' !! directorio donde se encuentran los config file logical :: asserts = . FALSE . !! si se activa se imprimen los datos de la factorizacion logical :: exists !! comprueba la existencia de los directorios de resultados real * 8 :: ancho , largo , espesor !! dimensiones de la placa real * 8 :: rigidez !! rigidez a flexion de la placa integer :: n , m !! numero de puntos para discretizar largo(n) y ancho(m) COMMON resultsFile , configFile !! variables globales ! comprueba si existe el directorio de resultados inquire ( file = resultsFile , exist = exists ) if (. NOT . exists ) resultsFile = 'result.html' ! si no existe crea el archivo al lado del programa ! inicio del programa call commandLine ( asserts ) ! opciones de ejecucion call bienvenido () ! mensaje de bienvenida (header) call datos ( ancho , largo , espesor , rigidez , n , m ) ! datos para poder funcionar el programa allocate ( matriz ( n * m , n * m )) ! fija la matriz de resultados numericos call constructMatriz ( ancho , largo , matriz , n , m ) ! construye la matriz para los resultados numericos allocate ( f ( n * m )) ! fija el vector de resultados numericos call constructVector ( largo , rigidez , f , n , m ) ! construye el vector para los resultados numericos ! muestra la matriz y factorizacion if ( asserts ) then call printMatrix ( matriz , 'Matriz' ) ! imprime en pantalla la matriz call printVector ( f , 'Vector' ) ! imprime en pantallas el vector de terminos independientes ! factorizacion y resultados call fCholesky ( matriz , n , m ) ! factorizada la matriz por cholesky call printMatrix ( matriz , 'Matriz (factorizada)' ) ! resolucion del sistema call linearSystem ( matriz , f , n , m ) call linearSystem ( matriz , f , n , m ) ! muestra solo la solucion else ! factoriza y resuelve call fCholesky ( matriz , n , m ) call linearSystem ( matriz , f , n , m ) call linearSystem ( matriz , f , n , m ) end if ! cambio de vector a matriz solucion allocate ( fMatriz ( m , n )) forma ( 1 ) = n forma ( 2 ) = m fMatriz = reshape ( f , forma , order = orden ) call printMatrix ( fMatriz , 'Vector solucion' ) call resNumericos ( ancho , largo , fMatriz , n , m ) ! calcula los resultados analiticos por Navier allocate ( navier ( m , n )) call analiticaNavier ( navier , ancho , largo , rigidez , n , m ) call resAnaliticos ( ancho , largo , navier , n , m ) ! para que no se cierre el programa derepente write ( * , * ) \"Gracias por usar el programa...\" read ( * , * ) contains !< Imprime una linea, un texto centrado y una línea. ! Creando como un titulo. subroutine header ( label ) character ( len =* ), intent ( in ) :: label character ( len = 30 ) :: formato character ( len = 2 ) :: iString integer :: i ! 30 is the line length / 2 i = 30 - len ( label ) / 2 write ( iString , '(i2)' ) i formato = '(' // iString // 'X,A)' call linea () write ( * , formato ) label call linea () end subroutine !< Imprime una matriz mas un texto como titulo. subroutine printMatrix ( matriz , label ) real * 8 , dimension (:,:), intent ( in ) :: matriz character ( len =* ), intent ( in ) :: label integer :: i , j call header ( label ) do i = 1 , ubound ( matriz , 1 ) write ( * , '(*(f0.4,5x))' ) ( matriz ( i , j ), j = 1 , ubound ( matriz , 2 )) end do call linea () end subroutine !< Imprime un vector mas un texto como titulo subroutine printVector ( f , label ) real * 8 , dimension (:), intent ( in ) :: f character ( len =* ), intent ( in ) :: label integer :: i call header ( label ) do i = 1 , ubound ( f , 1 ) write ( * , * ) f ( i ) end do call linea () end subroutine End Program WALLTER !< Imprime una línea de 60 caracteres. !  Se usa para separar la informacion que se imprime en la pantalla subroutine linea () write ( * , * ) \"____________________________________________________________\" end subroutine !< Analiza los argumentos cuando se ejecuto el programa. !  -h -> help: imprime las opciones disponibles. !  -a -> asserts: activa la impresion de los datos de la factorizacion. subroutine commandLine ( asserts ) logical , intent ( out ) :: asserts !! cuando es verdadera se activa la impresion de los datos de factorizacion integer :: i !! numero de argumentos character ( len = 30 ) :: cmd !! el argumento que se analiza character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile i = iargc () if ( i > 0 ) then do i = 1 , iargc () call getarg ( i , cmd ) if ( cmd == '-h' ) then write ( * , * ) 'Las opciones disponibles son:' write ( * , * ) '-h para ver esta ayuda' write ( * , * ) '-a para activar la impresion de los datos de factorizacion' write ( * , * ) '-c [FILENAME] para usar un programa de configuracion con los datos' call exit ( 0 ) end if if ( cmd == '-a' ) then write ( * , * ) 'Se ha activado la impresion de los datos de factorizacion.' asserts = . TRUE . end if if ( cmd == '-c' ) then write ( * , * ) 'Se usara para los datos el siguiente config file: ' call getarg ( i + 1 , configFile ) write ( * , * ) configFile exit end if end do end if end subroutine !< Imprime un mensaje de bienvenida subroutine bienvenido () write ( * , * ) \"                                  ,--,      ,--,           ,----,                     \" write ( * , * ) \"                               ,---.'|   ,---.'|         ,/   .`|                     \" write ( * , * ) \"           .---.   ,---,       |   | :   |   | :       ,`   .'  :   ,---,.,-.----.    \" write ( * , * ) \"          /. ./|  '  .' \\      :   : |   :   : |     ;    ;     / ,'  .' |\\    /  \\   \" write ( * , * ) \"      .--'.  ' ; /  ;    '.    |   ' :   |   ' :   .'___,/    ,',---.'   |;   :    \\  \" write ( * , * ) \"     /__./ \\ : |:  :       \\   ;   ; '   ;   ; '   |    :     | |   |   .'|   | .\\ :  \" write ( * , * ) \" .--'.  '   \\' .:  |   /\\   \\  '   | |__ '   | |__ ;    |.';  ; :   :  |-,.   : |: |  \" write ( * , * ) \"/___/ \\ |    ' '|  :  ' ;.   : |   | :.'||   | :.'|`----'  |  | :   |  ;/||   |  \\ :  \" write ( * , * ) \";   \\  \\;      :|  |  ;/  \\   \\'   :    ;'   :    ;    '   :  ; |   :   .'|   : .  /  \" write ( * , * ) \" \\   ;  `      |'  :  | \\  \\ ,'|   |  ./ |   |  ./     |   |  ' |   |  |-,;   | |  \\  \" write ( * , * ) \"  .   \\    .\\  ;|  |  '  '--'  ;   : ;   ;   : ;       '   :  | '   :  ;/||   | ;\\  \\ \" write ( * , * ) \"   \\   \\   ' \\ ||  :  :        |   ,/    |   ,/        ;   |.'  |   |    \\:   ' | \\.' \" write ( * , * ) \"    :   '  |--' |  | ,'        '---'     '---'         '---'    |   :   .':   : :-'   \" write ( * , * ) \"     \\   \\ ;    `--''                                           |   | ,'  |   |.'     \" write ( * , * ) \"      '---'                                                     `----'    `---'       \" write ( * , * ) \"Bienvenido -------> \" write ( * , '(20X,A)' ) \"Pulse enter para continuar\" read ( * , * ) end subroutine !< Solicita los datos necesarios para el calculo de la flecha. subroutine datos ( ancho , largo , espesor , rigidez , n , m ) integer * 4 , intent ( out ) :: n , m !! numero de puntos para discretizar la placa real * 8 , intent ( out ) :: largo , ancho , espesor !! dimensiones de la placa real * 8 , intent ( out ) :: rigidez !! rigidez a flexion -> D = E*t&#94;3/(12(1-v&#94;2)) real * 8 :: Young !! Modulo de Young real * 8 :: poisson !! Coeficiente de Poisson logical :: exists = . FALSE . !! existe el archivo de configuracion? character ( len = 50 ) :: label !! etiquetas del archivo de configuracion character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile ! comprueba que se haya definido un archivo de configuracion y de que existe if ( configFile /= '' ) then inquire ( file = configFile , exist = exists ) if (. NOT . exists ) then write ( * , * ) 'No se ha encontrado el archivo de configuracion.' write ( * , * ) end if end if ! si existe se abre y se lee la informacion if ( exists ) then open ( unit = 24 , file = configFile , status = 'old' , action = 'read' ) ! se abre ! se lee la informacion, quitando las etiquetas ! importante el orden read ( 24 , * ) label read ( 24 , * ) label , ancho read ( 24 , * ) label , largo read ( 24 , * ) label , espesor read ( 24 , * ) label read ( 24 , * ) label , n read ( 24 , * ) label , m read ( 24 , * ) label read ( 24 , * ) label , Young read ( 24 , * ) label , poisson ! se imprime los datos obtenidos por si el usuario los quiere cambiar write ( * , * ) \"Datos config file ::\" write ( * , '(5X,A,f0.3,A,f0.3,A,f0.3)' ) \"Datos placa ->\" , ancho , \" x \" , largo , \" x \" , espesor write ( * , '(5X,A,i2,A,i2,A)' ) \"Datos discretizacion [n,m] -> [\" , n , \",\" , m , \"]\" write ( * , '(5X,A,f0.1,A,f0.3)' ) \"Datos material -> Young:: \" , Young , \"; poisson:: \" , poisson else write ( * , * ) 'Se procede a pedir los datos al usuario.' write ( * , * ) 'Si se equivoca en algun numero podra cambiarlo al final de programa' ! Datos tecnicos de la placa write ( * , * ) \"*************************\" write ( * , * ) \"*   DATOS DE LA PLACA   *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> ancho de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) ancho write ( * , * ) \"-> largo de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) largo write ( * , * ) \"-> espesor de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) espesor ! datos para la discretizacion del modelo write ( * , * ) \"*************************\" write ( * , * ) \"*   NUMERO DE PUNTOS    *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> puntos para discretizar el ancho\" write ( * , '(A,$)' ) \"(integer) \" read ( * , * ) n write ( * , * ) \"-> puntos para discretizar el largo\" write ( * , '(A,$)' ) \"(integer) \" read ( * , * ) m ! propiedades del material write ( * , * ) \"*************************\" write ( * , * ) \"*   DATOS DEL MATERIAL  *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> Modulo de Young\" write ( * , '(A,$)' ) \"(MPa) \" read ( * , * ) Young write ( * , * ) \"-> Coef. de poisson\" write ( * , '(A,$)' ) \"(_real_) \" read ( * , * ) poisson end if ! MPa (N/mm3) -> 1000 KPa (kN/m2) rigidez = Young * 1000 * espesor ** 3 rigidez = rigidez / ( 12 * ( 1 - poisson ** 2 )) ! EXPORT HTML call createHTML ( \"resultados\" ) call exportMaterial ( Young , poisson ) call exportPlaca ( largo , ancho , espesor ) end subroutine !< Calculo los terminos de la matriz de resultados numericos y !  los coloca en su sitio. La matriz se almacena en banda. subroutine constructMatriz ( ancho , largo , matriz , n , m ) real * 8 , dimension ( n * m , n * m ), intent ( inout ) :: matriz real * 8 , intent ( in ) :: ancho , largo integer , intent ( in ) :: n , m real * 8 :: A , B , C , deltaX , deltaY integer :: i , j ! calculo de los coef A, B y C deltaX = ancho / ( n + 1 ) deltaY = largo / ( m + 1 ) B = 1 / ( deltaX ** 2 ) C = 1 / ( deltaY ** 2 ) A = - 2 * ( B + C ) write ( * , '(A,3(f0.2,X),A)' ) \"[A,B,C] -> [ \" , A , B , C , \"]\" !matriz y vector a cero do i = 1 , n * m do j = 1 , n * m matriz ( i , j ) = 0 end do end do ! construccion matriz do i = 1 , n * m matriz ( i , 1 ) = A if ( mod ( i , n ) == 0 . AND . i > 1 ) then matriz ( i , 2 ) = 0 else matriz ( i , 2 ) = B end if if ( i + n <= n * m ) matriz ( i , n + 1 ) = C end do end subroutine !< Construye el vector de resultados numericos subroutine constructVector ( largo , rigidez , vector , n , m ) real * 8 , dimension ( n * m ), intent ( inout ) :: vector real * 8 , intent ( in ) :: largo , rigidez integer , intent ( in ) :: n , m real * 8 :: deltaY , presion ! vector a cero do i = 1 , n * m vector ( i ) = 0 end do deltaY = largo / ( m + 1 ) ! construccion vector j = 1 do i = 1 , n * m ! peso especifico agua = 10000 N / m3 -> 10 kN / m3 presion = 10 * ( largo / 2 - j * deltaY ) / rigidez !solo hasta la mitad if ( presion < 0 ) then vector ( i ) = 0 else vector ( i ) = presion end if ! las filas tienen la misma presion if ( mod ( i , m ) == 0 ) j = j + 1 end do end subroutine !< Factorización de Cholesky -> A = L * D * Transpose[L] subroutine fCholesky ( matriz , n , m ) real * 8 , dimension ( n * m , n * m ), intent ( inout ) :: matriz integer :: k , i , j real * 8 :: suma ! factorizacion de cholesky do k = 1 , n * m - 1 do i = 1 , k suma = 0 do j = 1 , i - 1 suma = suma + matriz ( j , i - j + 1 ) * matriz ( j , k + 2 - j ) end do matriz ( i , k + 2 - i ) = ( matriz ( i , k + 2 - i ) - suma ) end do do i = 1 , k matriz ( i , k + 2 - i ) = matriz ( i , k + 2 - i ) / matriz ( i , 1 ) end do suma = 0 do j = 1 , k suma = suma + matriz ( j , k + 2 - j ) * matriz ( j , 1 ) * matriz ( j , k + 2 - j ) end do matriz ( k + 1 , 1 ) = matriz ( k + 1 , 1 ) - suma end do end subroutine !< Resolucion del sistema de ecuaciones para una matriz en banda factorizada subroutine linearSystem ( matriz , f , n , m ) real * 8 , dimension ( n * m , n * m ), intent ( inout ) :: matriz real * 8 , dimension ( n * m ), intent ( inout ) :: f integer , intent ( in ) :: n , m integer :: i , j real * 8 :: suma = 0 do i = 2 , n * m suma = 0 do j = 1 , i - 1 suma = suma + matriz ( j , i - j + 1 ) * f ( j ) end do f ( i ) = f ( i ) - suma end do do i = 1 , n * m f ( i ) = f ( i ) / matriz ( i , 1 ) end do do i = n * m - 1 , 1 , - 1 suma = 0 do j = i + 1 , n * m suma = suma + matriz ( i , j - i + 1 ) * f ( j ) end do f ( i ) = f ( i ) - suma end do end subroutine !< Resolucion del sistema mediante el metodo de Navier subroutine analiticaNavier ( w , ancho , largo , rigidez , n , m ) real * 8 , intent ( in ) :: ancho , largo real * 8 , intent ( in ) :: rigidez real * 8 , dimension ( m , n ), intent ( out ) :: w integer , intent ( in ) :: n , m integer :: i , j , r , s integer :: k , u real * 8 :: deltaX , deltaY , X , Y real * 8 :: p_ku , w_ku real * 8 :: pi = acos ( - 1.0 d0 ) logical :: exists = . FALSE . !! existe el archivo de configuracion? character ( len = 50 ) :: label !! etiquetas del archivo de configuracion character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile ! comprueba que se haya definido un archivo de configuracion y de que existe if ( configFile /= '' ) then inquire ( file = configFile , exist = exists ) if (. NOT . exists ) then write ( * , * ) 'No se ha encontrado el archivo de configuracion.' write ( * , * ) end if end if if ( exists ) then open ( unit = 24 , file = configFile , status = 'old' , action = 'read' ) read ( 24 , * ) label read ( 24 , * ) label , r read ( 24 , * ) label , s close ( 24 ) write ( * , * ) \"Los datos de \" , configFile , \" son:\" write ( * , '(A,I4,I4,A)' ) \"Número de iteraciones para el calculo analitico -> [r,s] = [\" , r , s , \"]\" else ! datos para el bucle de calculo de flecha write ( * , * ) 'Número de iteraciones para el calculo analitico:' write ( * , '(A,$)' ) 'n (interger): ' read ( * , * ) r write ( * , '(A,$)' ) 'm (interger): ' read ( * , * ) s end if !calculamos deltaX y deltaY deltaX = ancho / ( n + 1 ) deltaY = largo / ( m + 1 ) ! ceros en w do i = 1 , n do j = 1 , m w ( j , i ) = 0 end do end do !bucle para cada x e y do i = 1 , n X = i * deltaX do j = 1 , m Y = j * deltaY !bucle para el calculo de la flecha do k = 1 , r do u = 1 , s p_ku = 4 * largo * 10 * sin ( k * pi / 2 ) ** 2 / ( k * u ** 2 * pi ** 3 ) p_ku = p_ku * ( u * pi - 2 * sin ( u * pi / 2 )) w_ku = ( k ** 2 / ancho ** 2 + u ** 2 / largo ** 2 ) w_ku = w_ku ** 2 w_ku = p_ku / ( pi ** 4 * rigidez * w_ku ) w ( j , i ) = w ( j , i ) + w_ku * sin ( k * pi * X / ancho ) * sin ( u * pi * Y / largo ) end do end do end do end do do i = 1 , ubound ( w , 1 ) write ( * , '(*(f0.4,5x))' ) ( w ( i , j ), j = 1 , ubound ( w , 2 )) end do end subroutine","tags":"","loc":"sourcefile/main.f95.html"},{"title":"result.f95 – Fortran Program","text":"Subroutines createHTML exportMaterial exportPlaca resNumericos resAnaliticos Source Code result.f95 Source Code !< Crea el head y el principio del body del html de resultados ! para una mejor visualizacion del html, se recomienda crearlo7 ! en la carpeta result. Por defecto el programa lo hara asi. subroutine createHTML ( name ) character ( len =* ), intent ( in ) :: name character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile ) write ( 12 , '(A,$)' ) '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"' write ( 12 , * ) '\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">' write ( 12 , * ) '<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">' write ( 12 , * ) '<head>' write ( 12 , '(5X,3A)' ) '<title>' , name , '</title>' write ( 12 , '(5X,A)' ) '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />' write ( 12 , '(5X,A)' ) '<meta name=\"description\" content=\"\" />' write ( 12 , '(5X,A)' ) '<meta name=\"keywords\" content=\"\" />' write ( 12 , '(5X,A)' ) '<meta name=\"robots\" content=\"index,follow\" />' write ( 12 , '(5X,A)' ) '<link rel=\"stylesheet\" type=\"text/css\" href=\"./css/style.css\" />' write ( 12 , '(5X,A)' ) '<script src=\"https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.2.1.min.js\">' write ( 12 , '(5X,A)' ) '</script>' write ( 12 , '(5X,A)' ) '<script src=\"https://cdn.jsdelivr.net/clipboard.js/1.6.0/clipboard.min.js\">' write ( 12 , '(5X,A)' ) '</script>' write ( 12 , * ) '</head>' write ( 12 , * ) '<body>' write ( 12 , '(5X,A)' ) '<div class=\"row\">' write ( 12 , '(10X,A)' ) '<div class=\"header\">' write ( 12 , '(15X,A)' ) '<h1> Resultados del programa </h1>' write ( 12 , '(15X,A)' ) '<button id=\"bNumerico\">Resultados Numericos</button>' write ( 12 , '(15X,A)' ) '<button id=\"bAnalitico\">Resultados Analiticos</button>' write ( 12 , '(10X,A)' ) '</div>' write ( 12 , '(5X,A)' ) '</div>' close ( 12 ) end subroutine !< Escribe en la table de materiales en el html de resultados subroutine exportMaterial ( Young , poisson ) real * 8 , intent ( in ) :: Young , poisson character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(5X,A)' ) '<div class=\"row\">' write ( 12 , '(10X,A)' ) '<div class=\"box-item\">' write ( 12 , '(15X,A)' ) '<header> Material </header>' write ( 12 , '(15X,A)' ) '<p> El material empleado es : \t</p>' write ( 12 , '(15X,A)' ) '<table>' write ( 12 , '(20X,A,F0.3,A)' ) '<tr><td>E = ' , Young , ' MPa</td></tr>' write ( 12 , '(20X,A,F4.3,A)' ) '<tr><td>v = ' , poisson , '</td></tr>' write ( 12 , '(15X,A)' ) '</table>' close ( 12 ) end subroutine !< Escribe la table de datos de placa en el html de resultados subroutine exportPlaca ( largo , ancho , espesor ) real * 8 , intent ( in ) :: largo , ancho , espesor character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(15X,A)' ) '<header> Placa </header>' write ( 12 , '(15X,A)' ) '<p>Las medidas de la placa son:</p>' write ( 12 , '(15X,A)' ) '<table>' write ( 12 , '(20X,A,F6.3,A)' ) '<tr><td>Largo = ' , largo , ' m</td></tr>' write ( 12 , '(20X,A,F6.3,A)' ) '<tr><td>Ancho = ' , ancho , ' m</td></tr>' write ( 12 , '(20X,A,F4.3,A)' ) '<tr><td>Espesor = ' , espesor , ' m</td></tr>' write ( 12 , '(15X,A)' ) '</table>' write ( 12 , '(10X,A)' ) '</div>' close ( 12 ) end subroutine !< Escribe la table de resultados numericos en el html de resultados subroutine resNumericos ( ancho , largo , fMatriz , n , m ) real * 8 , dimension ( n , m ), intent ( in ) :: fMatriz real * 8 , intent ( in ) :: ancho , largo integer , intent ( in ) :: n , m real * 8 :: deltaX , deltaY character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile deltaX = ancho / ( n + 1 ) deltaY = largo / ( m + 1 ) open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(10X,A)' ) '<div class=\"box-item\" id=\"resultados\">' write ( 12 , '(15X,A)' ) '<header id=\"azul\"> Resultados </header>' write ( 12 , '(15X,A)' ) '<table id=\"tNumerico\">' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I5,A)' ) '<td rowspan=\"' , m + 2 , '\"> Y </th>' write ( 12 , '(20X,A)' ) '</tr>' do i = 1 , n write ( 12 , '(20X,A)' ) '<tr>' write ( 12 , '(25X,A,F0.3,A)' ) '<td class=\"td-h\">' , i * deltaX , '</td>' write ( 12 , '(25X,*(A,f0.4,A))' ) ( '<td>' , fMatriz ( i , j ), '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' end do write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A)' ) '<td>/</td>' write ( 12 , '(25X,*(A,F0.3,A))' ) ( '<td>' , j * deltaY , '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I4,A)' ) '<td>O</td><td colspan=\"' , n + 1 , '\">X</td>' write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(15X,A)' ) '</table>' close ( 12 ) end subroutine !< Escribe la table de resultados analiticos en el html de resultados subroutine resAnaliticos ( ancho , largo , navier , n , m ) real * 8 , dimension ( n , m ), intent ( in ) :: navier real * 8 , intent ( in ) :: ancho , largo integer , intent ( in ) :: n , m real * 8 :: deltaX , deltaY character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile deltaX = ancho / ( n + 1 ) deltaY = largo / ( m + 1 ) open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , '(15X,A)' ) '<table id=\"tAnalitico\">' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I5,A)' ) '<td rowspan=\"' , m + 2 , '\"> Y </th>' write ( 12 , '(20X,A)' ) '</tr>' do i = 1 , n write ( 12 , '(20X,A)' ) '<tr>' write ( 12 , '(25X,A,F0.3,A)' ) '<td class=\"td-h\">' , i * deltaX , '</td>' write ( 12 , '(25X,*(A,f0.4,A))' ) ( '<td>' , navier ( i , j ), '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' end do write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A)' ) '<td>/</td>' write ( 12 , '(25X,*(A,F0.3,A))' ) ( '<td>' , j * deltaY , '</td>' , j = 1 , m ) write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(20X,A)' ) '<tr class=\"tr-h\">' write ( 12 , '(25X,A,I4,A)' ) '<td>O</td><td colspan=\"' , n + 1 , '\">X</td>' write ( 12 , '(20X,A)' ) '</tr>' write ( 12 , '(15X,A)' ) '</table>' write ( 12 , '(10X,A)' ) '<button id=\"copyButton\" data-clipboard-action=\"copy\" data-clipboard-target=\".active\">' write ( 12 , '(15X,A)' ) 'Copia la tabla</button>' write ( 12 , '(10X,A)' ) '</div>' write ( 12 , '(5X,A)' ) '</div>' write ( 12 , '(5X,A)' ) '<script src=\"js/buttons.js\"></script>' write ( 12 , * ) '</body>' write ( 12 , * ) '</html>' close ( 12 ) end subroutine","tags":"","loc":"sourcefile/result.f95.html"},{"title":"linea – Fortran Program","text":"subroutine linea() Imprime una línea de 60 caracteres.\n  Se usa para separar la informacion que se imprime en la pantalla Arguments None Called By proc~~linea~~CalledByGraph proc~linea linea proc~header header proc~header->proc~linea proc~printvector printVector proc~printvector->proc~linea proc~printvector->proc~header proc~printmatrix printMatrix proc~printmatrix->proc~linea proc~printmatrix->proc~header program~wallter WALLTER program~wallter->proc~printvector program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linea.html"},{"title":"commandLine – Fortran Program","text":"subroutine commandLine(asserts) Analiza los argumentos cuando se ejecuto el programa.\n  -h -> help: imprime las opciones disponibles.\n  -a -> asserts: activa la impresion de los datos de la factorizacion. Arguments Type Intent Optional Attributes Name logical, intent(out) :: asserts cuando es verdadera se activa la impresion de los datos de factorizacion Called By proc~~commandline~~CalledByGraph proc~commandline commandLine program~wallter WALLTER program~wallter->proc~commandline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/commandline.html"},{"title":"bienvenido – Fortran Program","text":"subroutine bienvenido() Imprime un mensaje de bienvenida Arguments None Called By proc~~bienvenido~~CalledByGraph proc~bienvenido bienvenido program~wallter WALLTER program~wallter->proc~bienvenido Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/bienvenido.html"},{"title":"datos – Fortran Program","text":"subroutine datos(ancho, largo, espesor, rigidez, n, m) Solicita los datos necesarios para el calculo de la flecha. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: ancho dimensiones de la placa real(kind=8), intent(out) :: largo dimensiones de la placa real(kind=8), intent(out) :: espesor dimensiones de la placa real(kind=8), intent(out) :: rigidez rigidez a flexion -> D = E*t&#94;3/(12(1-v&#94;2)) integer(kind=4), intent(out) :: n numero de puntos para discretizar la placa integer(kind=4), intent(out) :: m numero de puntos para discretizar la placa Calls proc~~datos~~CallsGraph proc~datos datos proc~createhtml createHTML proc~datos->proc~createhtml proc~exportmaterial exportMaterial proc~datos->proc~exportmaterial proc~exportplaca exportPlaca proc~datos->proc~exportplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~datos~~CalledByGraph proc~datos datos program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/datos.html"},{"title":"constructMatriz – Fortran Program","text":"subroutine constructMatriz(ancho, largo, matriz, n, m) Calculo los terminos de la matriz de resultados numericos y\n  los coloca en su sitio. La matriz se almacena en banda. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(inout), dimension(n*m,n*m) :: matriz integer, intent(in) :: n integer, intent(in) :: m Called By proc~~constructmatriz~~CalledByGraph proc~constructmatriz constructMatriz program~wallter WALLTER program~wallter->proc~constructmatriz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/constructmatriz.html"},{"title":"constructVector – Fortran Program","text":"subroutine constructVector(largo, rigidez, vector, n, m) Construye el vector de resultados numericos Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: rigidez real(kind=8), intent(inout), dimension(n*m) :: vector integer, intent(in) :: n integer, intent(in) :: m Called By proc~~constructvector~~CalledByGraph proc~constructvector constructVector program~wallter WALLTER program~wallter->proc~constructvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/constructvector.html"},{"title":"fCholesky – Fortran Program","text":"subroutine fCholesky(matriz, n, m) Factorización de Cholesky -> A = L * D * Transpose[L] Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(n*m,n*m) :: matriz integer :: n integer :: m Called By proc~~fcholesky~~CalledByGraph proc~fcholesky fCholesky program~wallter WALLTER program~wallter->proc~fcholesky Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fcholesky.html"},{"title":"linearSystem – Fortran Program","text":"subroutine linearSystem(matriz, f, n, m) Resolucion del sistema de ecuaciones para una matriz en banda factorizada Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(n*m,n*m) :: matriz real(kind=8), intent(inout), dimension(n*m) :: f integer, intent(in) :: n integer, intent(in) :: m Called By proc~~linearsystem~~CalledByGraph proc~linearsystem linearSystem program~wallter WALLTER program~wallter->proc~linearsystem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linearsystem.html"},{"title":"analiticaNavier – Fortran Program","text":"subroutine analiticaNavier(w, ancho, largo, rigidez, n, m) Resolucion del sistema mediante el metodo de Navier Arguments Type Intent Optional Attributes Name real(kind=8), intent(out), dimension(m,n) :: w real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: rigidez integer, intent(in) :: n integer, intent(in) :: m Called By proc~~analiticanavier~~CalledByGraph proc~analiticanavier analiticaNavier program~wallter WALLTER program~wallter->proc~analiticanavier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/analiticanavier.html"},{"title":"createHTML – Fortran Program","text":"subroutine createHTML(name) Crea el head y el principio del body del html de resultados\n para una mejor visualizacion del html, se recomienda crearlo7\n en la carpeta result. Por defecto el programa lo hara asi. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Called By proc~~createhtml~~CalledByGraph proc~createhtml createHTML proc~datos datos proc~datos->proc~createhtml program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/createhtml.html"},{"title":"exportMaterial – Fortran Program","text":"subroutine exportMaterial(Young, poisson) Escribe en la table de materiales en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Young real(kind=8), intent(in) :: poisson Called By proc~~exportmaterial~~CalledByGraph proc~exportmaterial exportMaterial proc~datos datos proc~datos->proc~exportmaterial program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportmaterial.html"},{"title":"exportPlaca – Fortran Program","text":"subroutine exportPlaca(largo, ancho, espesor) Escribe la table de datos de placa en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: espesor Called By proc~~exportplaca~~CalledByGraph proc~exportplaca exportPlaca proc~datos datos proc~datos->proc~exportplaca program~wallter WALLTER program~wallter->proc~datos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportplaca.html"},{"title":"resNumericos – Fortran Program","text":"subroutine resNumericos(ancho, largo, fMatriz, n, m) Escribe la table de resultados numericos en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in), dimension(n,m) :: fMatriz integer, intent(in) :: n integer, intent(in) :: m Called By proc~~resnumericos~~CalledByGraph proc~resnumericos resNumericos program~wallter WALLTER program~wallter->proc~resnumericos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/resnumericos.html"},{"title":"resAnaliticos – Fortran Program","text":"subroutine resAnaliticos(ancho, largo, navier, n, m) Escribe la table de resultados analiticos en el html de resultados Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in), dimension(n,m) :: navier integer, intent(in) :: n integer, intent(in) :: m Called By proc~~resanaliticos~~CalledByGraph proc~resanaliticos resAnaliticos program~wallter WALLTER program~wallter->proc~resanaliticos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/resanaliticos.html"},{"title":"header – Fortran Program","text":"subroutine header(label) Imprime una linea, un texto centrado y una línea.\n Creando como un titulo. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Calls proc~~header~~CallsGraph proc~header header proc~linea linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~header~~CalledByGraph proc~header header proc~printvector printVector proc~printvector->proc~header proc~printmatrix printMatrix proc~printmatrix->proc~header program~wallter WALLTER program~wallter->proc~printvector program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/header.html"},{"title":"printMatrix – Fortran Program","text":"subroutine printMatrix(matriz, label) Imprime una matriz mas un texto como titulo. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: matriz character(len=*), intent(in) :: label Calls proc~~printmatrix~~CallsGraph proc~printmatrix printMatrix proc~header header proc~printmatrix->proc~header proc~linea linea proc~printmatrix->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~printmatrix~~CalledByGraph proc~printmatrix printMatrix program~wallter WALLTER program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/printmatrix.html"},{"title":"printVector – Fortran Program","text":"subroutine printVector(f, label) Imprime un vector mas un texto como titulo Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: f character(len=*), intent(in) :: label Calls proc~~printvector~~CallsGraph proc~printvector printVector proc~header header proc~printvector->proc~header proc~linea linea proc~printvector->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~printvector~~CalledByGraph proc~printvector printVector program~wallter WALLTER program~wallter->proc~printvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/printvector.html"},{"title":"WALLTER – Fortran Program","text":"Programa para el calculo de flechas de una placa apoyada\n  en sus cantos con carga hidraulica hasta la mitad de su largo Calls program~~wallter~~CallsGraph program~wallter WALLTER proc~fcholesky fCholesky program~wallter->proc~fcholesky proc~bienvenido bienvenido program~wallter->proc~bienvenido proc~resnumericos resNumericos program~wallter->proc~resnumericos proc~analiticanavier analiticaNavier program~wallter->proc~analiticanavier proc~constructmatriz constructMatriz program~wallter->proc~constructmatriz proc~commandline commandLine program~wallter->proc~commandline proc~linearsystem linearSystem program~wallter->proc~linearsystem proc~printvector printVector program~wallter->proc~printvector proc~resanaliticos resAnaliticos program~wallter->proc~resanaliticos proc~constructvector constructVector program~wallter->proc~constructvector proc~datos datos program~wallter->proc~datos proc~printmatrix printMatrix program~wallter->proc~printmatrix proc~header header proc~printvector->proc~header proc~linea linea proc~printvector->proc~linea proc~createhtml createHTML proc~datos->proc~createhtml proc~exportmaterial exportMaterial proc~datos->proc~exportmaterial proc~exportplaca exportPlaca proc~datos->proc~exportplaca proc~printmatrix->proc~header proc~printmatrix->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Variables matriz f navier fMatriz forma orden resultsFile configFile asserts exists ancho largo espesor rigidez n m Subroutines header printMatrix printVector Common Blocks common variables globales Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n       $('[data-toggle=\"popover\"]').popover()\n       }) Variables Type Attributes Name Initial real(kind=8), dimension(:,:), allocatable :: matriz sistema de ecuaciones real(kind=8), dimension(:), allocatable :: f vector terminos independientes real(kind=8), dimension(:,:), allocatable :: navier vector terminos analiticos real(kind=8), dimension(:,:), allocatable :: fMatriz solucion en forma matricial integer, dimension(2) :: forma forma de la matriz solucion integer, dimension(2) :: orden = (/2, 1/) orden de los numeros al cambiar vector a matriz solucion character(len=50) :: resultsFile = './result/resultados.html' directorio donde se escribiran los resultados character(len=50) :: configFile = '' directorio donde se encuentran los config file logical :: asserts = .FALSE. si se activa se imprimen los datos de la factorizacion logical :: exists comprueba la existencia de los directorios de resultados real(kind=8) :: ancho dimensiones de la placa real(kind=8) :: largo dimensiones de la placa real(kind=8) :: espesor dimensiones de la placa real(kind=8) :: rigidez rigidez a flexion de la placa integer :: n numero de puntos para discretizar largo(n) y ancho(m) integer :: m numero de puntos para discretizar largo(n) y ancho(m) Subroutines subroutine header (label) Imprime una linea, un texto centrado y una línea.\n Creando como un titulo. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label subroutine printMatrix (matriz, label) Imprime una matriz mas un texto como titulo. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: matriz character(len=*), intent(in) :: label subroutine printVector (f, label) Imprime un vector mas un texto como titulo Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: f character(len=*), intent(in) :: label","tags":"","loc":"program/wallter.html"}]}