var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is . This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. [[linalg]] Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like  y = x&#94;2  or math on its own line\nlike  x = \\sqrt{y}  or  e = mc&#94;2.  You can even use LaTeX environments!\nSo you can get numbered equations like this:\n\\begin{equation}\n  PV = nRT\n\\end{equation}\nSo let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info Franterminator I program stuff in Fortran.","tags":"","loc":"index.html"},{"title":"main.f95 – Fortran Program","text":"Programs WALLTER Subroutines linea commandLine bienvenido datosPlaca constructor fCholesky linearSystem analiticaNavier createHTML exportMaterial exportPlaca exportResultados Source Code main.f95 Source Code !< author: francisco rivera alvarez !  Programa para el calculo de flechas de una placa apoyada !  en sus cantos con carga hidraulica hasta la mitad de su largo Program WALLTER !< Interface para poder fijar las dimensiones de la matriz en la ! subroutine constructor interface subroutine constructor ( matriz , f , navier , n , m ) real * 8 , dimension (:,:), allocatable , intent ( inout ) :: matriz !! sistema de ecuaciones real * 8 , dimension (:), allocatable , intent ( inout ) :: f !! vector terminos independientes real * 8 , dimension (:,:), allocatable , intent ( inout ) :: navier !! resultados analiticos integer , intent ( out ) :: n , m end subroutine end interface real * 8 , dimension (:,:), allocatable :: matriz !! sistema de ecuaciones real * 8 , dimension (:), allocatable :: f !! vector terminos independientes real * 8 , dimension (:,:), allocatable :: navier integer :: n , m !! numero de puntos para discretizar largo(n) y ancho(m) real * 8 , dimension (:,:), allocatable :: fMatriz !! solucion en forma matricial integer , dimension ( 2 ) :: forma !! forma de la matriz solucion integer , dimension ( 2 ) :: orden = ( / 2 , 1 / ) !! orden de los numeros al cambiar vector a matriz solucion character ( len = 50 ) :: resultsFile = './result/resultados.html' character ( len = 50 ) :: configFile = '' logical :: asserts = . FALSE . !! si se activa se imprimen los datos de la factorizacion logical :: exists COMMON resultsFile , configFile inquire ( file = resultsFile , exist = exists ) if (. NOT . exists ) resultsFile = 'result.html' ! inicio del programa call commandLine ( asserts ) ! opciones de ejecucion call bienvenido () ! mensaje de bienvenida (header) call constructor ( matriz , f , navier , n , m ) ! calculo de las matrices ! muestra la matriz y factorizacion if ( asserts ) then call printMatrix ( matriz , 'Matriz' ) ! imprime en pantalla la matriz call printVector ( f , 'Vector' ) ! imprime en pantallas el vector de terminos independientes ! factorizacion y resultados call fCholesky ( matriz , n , m ) ! factorizada la matriz por cholesky call printMatrix ( matriz , 'Matriz (factorizada)' ) ! resolucion del sistema call linearSystem ( matriz , f , n , m ) ! resuelve call linearSystem ( matriz , f , n , m ) ! resuelve ! cambio de vector a matriz solucion allocate ( fMatriz ( n , m )) forma ( 1 ) = n forma ( 2 ) = m fMatriz = reshape ( f , forma , order = orden ) call printMatrix ( fMatriz , 'Vector solucion' ) call exportResultados ( fMatriz , n , m ) ! muestra solo la solucion else ! factoriza y resuelve call fCholesky ( matriz , n , m ) call linearSystem ( matriz , f , n , m ) call linearSystem ( matriz , f , n , m ) ! cambio de vector a matriz solucion allocate ( fMatriz ( n , m )) forma ( 1 ) = n forma ( 2 ) = m fMatriz = reshape ( f , forma , order = orden ) call printMatrix ( fMatriz , 'Vector solucion' ) call exportResultados ( fMatriz , n , m ) end if ! para que no se cierre el programa derepente write ( * , * ) \"Gracias por usar el programa...\" read ( * , * ) contains !< Imprime una linea, un texto centrado y una línea. ! Creando como un titulo. subroutine header ( label ) character ( len =* ), intent ( in ) :: label character ( len = 30 ) :: formato character ( len = 2 ) :: iString integer :: i ! 30 is the line length / 2 i = 30 - len ( label ) / 2 write ( iString , '(i2)' ) i formato = '(' // iString // 'X,A)' call linea () write ( * , formato ) label call linea () end subroutine !< Imprime una matriz mas un texto como titulo. subroutine printMatrix ( matriz , label ) real * 8 , dimension (:,:), intent ( in ) :: matriz character ( len =* ), intent ( in ) :: label integer :: i , j call header ( label ) do i = 1 , ubound ( matriz , 1 ) write ( * , '(*(f0.4,5x))' ) ( matriz ( i , j ), j = 1 , ubound ( matriz , 2 )) end do call linea () end subroutine !< Imprime un vector mas un texto como titulo subroutine printVector ( f , label ) real * 8 , dimension (:), intent ( in ) :: f character ( len =* ), intent ( in ) :: label integer :: i call header ( label ) do i = 1 , ubound ( f , 1 ) write ( * , * ) f ( i ) end do call linea () end subroutine End Program WALLTER !< Imprime una línea de 60 caracteres. !  Se usa para separar la informacion que se imprime en la pantalla subroutine linea () write ( * , * ) \"____________________________________________________________\" end subroutine !< Analiza los argumentos cuando se ejecuto el programa. !  -h -> help: imprime las opciones disponibles. !  -a -> asserts: activa la impresion de los datos de la factorizacion. subroutine commandLine ( asserts ) logical , intent ( out ) :: asserts !! cuando es verdadera se activa la impresion de los datos de factorizacion integer :: i !! numero de argumentos character ( len = 30 ) :: cmd !! el argumento que se analiza character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile i = iargc () if ( i > 0 ) then do i = 1 , iargc () call getarg ( i , cmd ) if ( cmd == '-h' ) then write ( * , * ) 'Las opciones disponibles son:' write ( * , * ) '-h para ver esta ayuda' write ( * , * ) '-a para activar la impresion de los datos de factorizacion' write ( * , * ) '-c [FILENAME] para usar un programa de configuracion con los datos' call exit ( 0 ) end if if ( cmd == '-a' ) then write ( * , * ) 'Se ha activado la impresion de los datos de factorizacion.' asserts = . TRUE . end if if ( cmd == '-c' ) then write ( * , * ) 'Se usara para los datos el siguiente config file: ' call getarg ( i + 1 , configFile ) write ( * , * ) configFile exit end if end do end if end subroutine !< Imprime un mensaje de bienvenida subroutine bienvenido () write ( * , * ) \"                                  ,--,      ,--,           ,----,                     \" write ( * , * ) \"                               ,---.'|   ,---.'|         ,/   .`|                     \" write ( * , * ) \"           .---.   ,---,       |   | :   |   | :       ,`   .'  :   ,---,.,-.----.    \" write ( * , * ) \"          /. ./|  '  .' \\      :   : |   :   : |     ;    ;     / ,'  .' |\\    /  \\   \" write ( * , * ) \"      .--'.  ' ; /  ;    '.    |   ' :   |   ' :   .'___,/    ,',---.'   |;   :    \\  \" write ( * , * ) \"     /__./ \\ : |:  :       \\   ;   ; '   ;   ; '   |    :     | |   |   .'|   | .\\ :  \" write ( * , * ) \" .--'.  '   \\' .:  |   /\\   \\  '   | |__ '   | |__ ;    |.';  ; :   :  |-,.   : |: |  \" write ( * , * ) \"/___/ \\ |    ' '|  :  ' ;.   : |   | :.'||   | :.'|`----'  |  | :   |  ;/||   |  \\ :  \" write ( * , * ) \";   \\  \\;      :|  |  ;/  \\   \\'   :    ;'   :    ;    '   :  ; |   :   .'|   : .  /  \" write ( * , * ) \" \\   ;  `      |'  :  | \\  \\ ,'|   |  ./ |   |  ./     |   |  ' |   |  |-,;   | |  \\  \" write ( * , * ) \"  .   \\    .\\  ;|  |  '  '--'  ;   : ;   ;   : ;       '   :  | '   :  ;/||   | ;\\  \\ \" write ( * , * ) \"   \\   \\   ' \\ ||  :  :        |   ,/    |   ,/        ;   |.'  |   |    \\:   ' | \\.' \" write ( * , * ) \"    :   '  |--' |  | ,'        '---'     '---'         '---'    |   :   .':   : :-'   \" write ( * , * ) \"     \\   \\ ;    `--''                                           |   | ,'  |   |.'     \" write ( * , * ) \"      '---'                                                     `----'    `---'       \" write ( * , * ) \"Bienvenido -------> \" write ( * , '(20X,A)' ) \"Pulse enter para continuar\" read ( * , * ) end subroutine !< Solicita los datos necesarios para el calculo de la flecha. subroutine datosPlaca ( ancho , largo , espesor , rigidez , n , m ) integer * 4 , intent ( out ) :: n , m !! numero de puntos para discretizar la placa real * 8 , intent ( out ) :: largo , ancho , espesor !! dimensiones de la placa real * 8 , intent ( out ) :: rigidez !! rigidez a flexion -> D = E*t&#94;3/(12(1-v&#94;2)) real * 8 :: Young !! Modulo de Young real * 8 :: poisson !! Coeficiente de Poisson logical :: exists = . FALSE . !! existe el archivo de configuracion? character ( len = 50 ) :: label !! etiquetas del archivo de configuracion character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile ! comprueba que se haya definido un archivo de configuracion y de que existe if ( configFile /= '' ) then inquire ( file = configFile , exist = exists ) if (. NOT . exists ) then write ( * , * ) 'No se ha encontrado el archivo de configuracion.' write ( * , * ) end if end if ! si existe se abre y se lee la informacion if ( exists ) then open ( unit = 24 , file = configFile , status = 'old' , action = 'read' ) ! se abre ! se lee la informacion, quitando las etiquetas ! importante el orden read ( 24 , * ) label read ( 24 , * ) label , ancho read ( 24 , * ) label , largo read ( 24 , * ) label , espesor read ( 24 , * ) label read ( 24 , * ) label , n read ( 24 , * ) label , m read ( 24 , * ) label read ( 24 , * ) label , Young read ( 24 , * ) label , poisson ! se imprime los datos obtenidos por si el usuario los quiere cambiar write ( * , * ) \"Datos config file ::\" write ( * , '(5X,A,f0.3,A,f0.3,A,f0.3)' ) \"Datos placa ->\" , ancho , \" x \" , largo , \" x \" , espesor write ( * , '(5X,A,i2,A,i2,A)' ) \"Datos discretizacion [n,m] -> [\" , n , \",\" , m , \"]\" write ( * , '(5X,A,f0.1,A,f0.3)' ) \"Datos material -> Young:: \" , Young , \"; poisson:: \" , poisson else write ( * , * ) 'Se procede a pedir los datos al usuario.' write ( * , * ) 'Si se equivoca en algun numero podra cambiarlo al final de programa' ! Datos tecnicos de la placa write ( * , * ) \"*************************\" write ( * , * ) \"*   DATOS DE LA PLACA   *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> ancho de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) ancho write ( * , * ) \"-> largo de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) largo write ( * , * ) \"-> espesor de la placa\" write ( * , '(A,$)' ) \"(metros) \" read ( * , * ) espesor ! datos para la discretizacion del modelo write ( * , * ) \"*************************\" write ( * , * ) \"*   NUMERO DE PUNTOS    *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> puntos para discretizar el ancho\" write ( * , '(A,$)' ) \"(integer) \" read ( * , * ) n write ( * , * ) \"-> puntos para discretizar el largo\" write ( * , '(A,$)' ) \"(integer) \" read ( * , * ) m ! propiedades del material write ( * , * ) \"*************************\" write ( * , * ) \"*   DATOS DEL MATERIAL  *\" write ( * , * ) \"*************************\" write ( * , * ) \"-> Modulo de Young\" write ( * , '(A,$)' ) \"(MPa) \" read ( * , * ) Young write ( * , * ) \"-> Coef. de poisson\" write ( * , '(A,$)' ) \"(_real_) \" read ( * , * ) poisson end if ! MPa (N/mm3) -> 1000 KPa (kN/m2) rigidez = Young * 1000 * espesor ** 3 rigidez = rigidez / ( 12 * ( 1 - poisson ** 2 )) ! EXPORT HTML call createHTML ( \"resultados\" ) call exportMaterial ( Young , poisson ) call exportPlaca ( largo , ancho , espesor ) end subroutine !< Calculo los terminos de la matriz y el vector de terminso independientes y !  los coloca en su sitio. La matriz se almacena en banda. subroutine constructor ( matriz , f , navier , n , m ) real * 8 , dimension (:,:), allocatable , intent ( inout ) :: matriz real * 8 , dimension (:), allocatable , intent ( inout ) :: f real * 8 , dimension (:,:), allocatable , intent ( inout ) :: navier integer , intent ( out ) :: n , m real * 8 :: ancho , largo , espesor , A , B , C , deltaX , deltaY real * 8 :: rigidez , presion integer :: i , j character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile call datosPlaca ( ancho , largo , espesor , rigidez , n , m ) allocate ( navier ( n , m )) call analiticaNavier ( navier , ancho , largo , rigidez , n , m ) ! calculo de los coef A, B y C deltaX = ancho / ( n + 1 ) deltaY = largo / ( m + 1 ) B = 1 / ( deltaX ** 2 ) C = 1 / ( deltaY ** 2 ) A = - 2 * ( B + C ) write ( * , '(A,3(f0.2,X),A)' ) \"[A,B,C] -> [ \" , A , B , C , \"]\" !matriz y vector a cero allocate ( matriz ( n * m , n * m ), f ( n * m )) do i = 1 , n * m f ( i ) = 0 do j = 1 , n * m matriz ( i , j ) = 0 end do end do ! construccion matriz do i = 1 , n * m matriz ( i , 1 ) = A if ( mod ( i , n ) == 0 . AND . i > 1 ) then matriz ( i , 2 ) = 0 else matriz ( i , 2 ) = B end if if ( i + n <= n * m ) matriz ( i , n + 1 ) = C end do ! construccion vector j = 1 do i = 1 , n * m ! peso especifico agua = 10000 N / m3 -> 10 kN / m3 presion = 10 * ( largo / 2 - j * deltaY ) / rigidez !solo hasta la mitad if ( presion < 0 ) then f ( i ) = 0 else f ( i ) = presion end if ! las filas tienen la misma presion if ( mod ( i , m ) == 0 ) j = j + 1 end do end subroutine !< Factorización de Cholesky -> A = L * D * Transpose[L] subroutine fCholesky ( matriz , n , m ) real * 8 , dimension ( n * m , n * m ), intent ( inout ) :: matriz integer :: k , i , j real * 8 :: suma ! factorizacion de cholesky do k = 1 , n * m - 1 do i = 1 , k suma = 0 do j = 1 , i - 1 suma = suma + matriz ( j , i - j + 1 ) * matriz ( j , k + 2 - j ) end do matriz ( i , k + 2 - i ) = ( matriz ( i , k + 2 - i ) - suma ) end do do i = 1 , k matriz ( i , k + 2 - i ) = matriz ( i , k + 2 - i ) / matriz ( i , 1 ) end do suma = 0 do j = 1 , k suma = suma + matriz ( j , k + 2 - j ) * matriz ( j , 1 ) * matriz ( j , k + 2 - j ) end do matriz ( k + 1 , 1 ) = matriz ( k + 1 , 1 ) - suma end do end subroutine !< Resolucion del sistema de ecuaciones para una matriz en banda factorizada subroutine linearSystem ( matriz , f , n , m ) real * 8 , dimension ( n * m , n * m ), intent ( inout ) :: matriz real * 8 , dimension ( n * m ), intent ( inout ) :: f integer , intent ( in ) :: n , m integer :: i , j real * 8 :: suma = 0 do i = 2 , n * m suma = 0 do j = 1 , i - 1 suma = suma + matriz ( j , i - j + 1 ) * f ( j ) end do f ( i ) = f ( i ) - suma end do do i = 1 , n * m f ( i ) = f ( i ) / matriz ( i , 1 ) end do do i = n * m - 1 , 1 , - 1 suma = 0 do j = i + 1 , n * m suma = suma + matriz ( i , j - i + 1 ) * f ( j ) end do f ( i ) = f ( i ) - suma end do end subroutine subroutine analiticaNavier ( w , ancho , largo , rigidez , n , m ) real * 8 , intent ( in ) :: ancho , largo real * 8 , intent ( in ) :: rigidez real * 8 , dimension ( n , m ), intent ( out ) :: w integer , intent ( in ) :: n , m integer :: i , j , p , q integer :: k , u real * 8 :: deltaX , deltaY , X , Y real * 8 :: p_ij , w_ij real * 8 :: pi = acos ( - 1.0 d0 ) ! datos para el bucle de calculo de flecha write ( * , * ) 'Número de iteraciones para el calculo analitico:' write ( * , '(A,$)' ) 'n (interger):' read ( * , * ) r write ( * , '(A,$)' ) 'm (interger):' read ( * , * ) s !calculamos deltaX y deltaY deltaX = ancho / ( n + 1 ) deltaY = largo / ( m + 1 ) ! ceros en w do i = 1 , n do j = 1 , m w ( i , j ) = 0 end do end do !bucle para cada x e y do i = 1 , n X = i * deltaX do j = 1 , m Y = j * deltaY !bucle para el calculo de la flecha do k = 1 , r do u = 1 , s p_ku = 4 * largo * 10 * sin ( k * pi / 2 ) ** 2 / ( k * u ** 2 * pi ** 3 ) p_ku = p_ku * ( u * pi - 2 * sin ( u * pi / 2 )) w_ku = ( k ** 2 / ancho ** 2 + u ** 2 / largo ** 2 ) w_ku = w_ku ** 2 w_ku = p_ku / ( pi ** 4 * rigidez * w_ku ) w ( i , j ) = w ( i , j ) + w_ku * sin ( k * pi * X / ancho ) * sin ( u * pi * Y / largo ) end do end do end do end do do i = 1 , ubound ( w , 1 ) write ( * , '(*(f0.4,5x))' ) ( w ( i , j ), j = 1 , ubound ( w , 2 )) end do end subroutine subroutine createHTML ( name ) character ( len =* ), intent ( in ) :: name character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile ) write ( 12 , * ) '<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">' write ( 12 , * ) '<head>' write ( 12 , * ) '<title>' , name , '</title>' write ( 12 , * ) '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />' write ( 12 , * ) '<meta name=\"description\" content=\"\" />' write ( 12 , * ) '<meta name=\"keywords\" content=\"\" />' write ( 12 , * ) '<meta name=\"robots\" content=\"index,follow\" />' write ( 12 , * ) '<link rel=\"stylesheet\" type=\"text/css\" href=\"./css/style.css\" />' write ( 12 , * ) '</head>' write ( 12 , * ) '<body>' write ( 12 , * ) '<div class=\"row\">' write ( 12 , * ) '<div class=\"header\">' write ( 12 , * ) '<h1> Resultados del programa </h1>' write ( 12 , * ) '</div>' write ( 12 , * ) '</div>' close ( 12 ) end subroutine subroutine exportMaterial ( Young , poisson ) real * 8 , intent ( in ) :: Young , poisson character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , * ) '<div class=\"row\">' write ( 12 , * ) '<div class=\"box-item\">' write ( 12 , * ) '<header> Material </header>' write ( 12 , * ) '<p> El material empleado es : \t</p>' write ( 12 , * ) '<table>' write ( 12 , * ) '<tr><td>E = ' , Young , 'MPa</td></tr>' write ( 12 , * ) '<tr><td>v = ' , poisson , '</td></tr>' write ( 12 , * ) '</table>' close ( 12 ) end subroutine subroutine exportPlaca ( largo , ancho , espesor ) real * 8 , intent ( in ) :: largo , ancho , espesor character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , * ) '<header> Placa </header>' write ( 12 , * ) '<p>Las medidas de la placa son:</p>' write ( 12 , * ) '<table>' write ( 12 , * ) '<tr><td>Largo = ' , largo , ' m</td></tr>' write ( 12 , * ) '<tr><td>Ancho = ' , ancho , ' m</td></tr>' write ( 12 , * ) '<tr><td>Espesor = ' , espesor , ' m</td></tr>' write ( 12 , * ) '</table>' write ( 12 , * ) '</div>' close ( 12 ) end subroutine subroutine exportResultados ( fMatriz , n , m ) real * 8 , dimension ( n , m ), intent ( in ) :: fMatriz integer , intent ( in ) :: n , m character ( len = 50 ) :: resultsFile , configFile COMMON resultsFile , configFile open ( unit = 12 , file = resultsFile , status = 'old' , position = \"append\" ) write ( 12 , * ) '<div class=\"box-item\" id=\"resultados\">' write ( 12 , * ) '<header id=\"azul\"> Resultados </header>' write ( 12 , * ) '<table>' write ( 12 , * ) '<th rowspan=\"' , m + 2 , '\"> Y </th>' write ( 12 , * ) '<th colspan=\"' , n , '\"> X </th>' write ( 12 , * ) '<tr class=\"tr-header\">' write ( 12 , * ) ( '<td>' , 2 * j , '</td>' , j = 1 , m ) write ( 12 , * ) '</tr>' do i = 1 , n write ( 12 , * ) '<tr>' write ( 12 , '(*(A,f0.4,5x,A))' ) ( '<td>' , fMatriz ( i , j ), '</td>' , j = 1 , m ) write ( 12 , * ) '</tr>' end do write ( 12 , * ) '</table>' close ( 12 ) end subroutine","tags":"","loc":"sourcefile/main.f95.html"},{"title":"linea – Fortran Program","text":"subroutine linea() Imprime una línea de 60 caracteres.\n  Se usa para separar la informacion que se imprime en la pantalla Arguments None Called By proc~~linea~~CalledByGraph proc~linea linea proc~printvector printVector proc~printvector->proc~linea proc~header header proc~printvector->proc~header proc~header->proc~linea proc~printmatrix printMatrix proc~printmatrix->proc~linea proc~printmatrix->proc~header program~wallter WALLTER program~wallter->proc~printvector program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linea.html"},{"title":"commandLine – Fortran Program","text":"subroutine commandLine(asserts) Analiza los argumentos cuando se ejecuto el programa.\n  -h -> help: imprime las opciones disponibles.\n  -a -> asserts: activa la impresion de los datos de la factorizacion. Arguments Type Intent Optional Attributes Name logical, intent(out) :: asserts cuando es verdadera se activa la impresion de los datos de factorizacion Called By proc~~commandline~~CalledByGraph proc~commandline commandLine program~wallter WALLTER program~wallter->proc~commandline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/commandline.html"},{"title":"bienvenido – Fortran Program","text":"subroutine bienvenido() Imprime un mensaje de bienvenida Arguments None Called By proc~~bienvenido~~CalledByGraph proc~bienvenido bienvenido program~wallter WALLTER program~wallter->proc~bienvenido Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/bienvenido.html"},{"title":"datosPlaca – Fortran Program","text":"subroutine datosPlaca(ancho, largo, espesor, rigidez, n, m) Solicita los datos necesarios para el calculo de la flecha. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: ancho dimensiones de la placa real(kind=8), intent(out) :: largo dimensiones de la placa real(kind=8), intent(out) :: espesor dimensiones de la placa real(kind=8), intent(out) :: rigidez rigidez a flexion -> D = E*t&#94;3/(12(1-v&#94;2)) integer(kind=4), intent(out) :: n numero de puntos para discretizar la placa integer(kind=4), intent(out) :: m numero de puntos para discretizar la placa Calls proc~~datosplaca~~CallsGraph proc~datosplaca datosPlaca proc~createhtml createHTML proc~datosplaca->proc~createhtml proc~exportmaterial exportMaterial proc~datosplaca->proc~exportmaterial proc~exportplaca exportPlaca proc~datosplaca->proc~exportplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~datosplaca~~CalledByGraph proc~datosplaca datosPlaca proc~constructor constructor proc~constructor->proc~datosplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/datosplaca.html"},{"title":"constructor – Fortran Program","text":"subroutine constructor(matriz, f, navier, n, m) Calculo los terminos de la matriz y el vector de terminso independientes y\n  los coloca en su sitio. La matriz se almacena en banda. Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:), allocatable :: matriz real(kind=8), intent(inout), dimension(:), allocatable :: f real(kind=8), intent(inout), dimension(:,:), allocatable :: navier integer, intent(out) :: n integer, intent(out) :: m Calls proc~~constructor~~CallsGraph proc~constructor constructor proc~analiticanavier analiticaNavier proc~constructor->proc~analiticanavier proc~datosplaca datosPlaca proc~constructor->proc~datosplaca proc~createhtml createHTML proc~datosplaca->proc~createhtml proc~exportmaterial exportMaterial proc~datosplaca->proc~exportmaterial proc~exportplaca exportPlaca proc~datosplaca->proc~exportplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/constructor.html"},{"title":"fCholesky – Fortran Program","text":"subroutine fCholesky(matriz, n, m) Factorización de Cholesky -> A = L * D * Transpose[L] Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(n*m,n*m) :: matriz integer :: n integer :: m Called By proc~~fcholesky~~CalledByGraph proc~fcholesky fCholesky program~wallter WALLTER program~wallter->proc~fcholesky Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fcholesky.html"},{"title":"linearSystem – Fortran Program","text":"subroutine linearSystem(matriz, f, n, m) Resolucion del sistema de ecuaciones para una matriz en banda factorizada Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(n*m,n*m) :: matriz real(kind=8), intent(inout), dimension(n*m) :: f integer, intent(in) :: n integer, intent(in) :: m Called By proc~~linearsystem~~CalledByGraph proc~linearsystem linearSystem program~wallter WALLTER program~wallter->proc~linearsystem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linearsystem.html"},{"title":"analiticaNavier – Fortran Program","text":"subroutine analiticaNavier(w, ancho, largo, rigidez, n, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out), dimension(n,m) :: w real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: rigidez integer, intent(in) :: n integer, intent(in) :: m Called By proc~~analiticanavier~~CalledByGraph proc~analiticanavier analiticaNavier proc~constructor constructor proc~constructor->proc~analiticanavier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/analiticanavier.html"},{"title":"createHTML – Fortran Program","text":"subroutine createHTML(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Called By proc~~createhtml~~CalledByGraph proc~createhtml createHTML proc~datosplaca datosPlaca proc~datosplaca->proc~createhtml proc~constructor constructor proc~constructor->proc~datosplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/createhtml.html"},{"title":"exportMaterial – Fortran Program","text":"subroutine exportMaterial(Young, poisson) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Young real(kind=8), intent(in) :: poisson Called By proc~~exportmaterial~~CalledByGraph proc~exportmaterial exportMaterial proc~datosplaca datosPlaca proc~datosplaca->proc~exportmaterial proc~constructor constructor proc~constructor->proc~datosplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportmaterial.html"},{"title":"exportPlaca – Fortran Program","text":"subroutine exportPlaca(largo, ancho, espesor) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: largo real(kind=8), intent(in) :: ancho real(kind=8), intent(in) :: espesor Called By proc~~exportplaca~~CalledByGraph proc~exportplaca exportPlaca proc~datosplaca datosPlaca proc~datosplaca->proc~exportplaca proc~constructor constructor proc~constructor->proc~datosplaca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportplaca.html"},{"title":"exportResultados – Fortran Program","text":"subroutine exportResultados(fMatriz, n, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(n,m) :: fMatriz integer, intent(in) :: n integer, intent(in) :: m Called By proc~~exportresultados~~CalledByGraph proc~exportresultados exportResultados program~wallter WALLTER program~wallter->proc~exportresultados Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/exportresultados.html"},{"title":"header – Fortran Program","text":"subroutine header(label) Imprime una linea, un texto centrado y una línea.\n Creando como un titulo. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Calls proc~~header~~CallsGraph proc~header header proc~linea linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~header~~CalledByGraph proc~header header proc~printvector printVector proc~printvector->proc~header proc~printmatrix printMatrix proc~printmatrix->proc~header program~wallter WALLTER program~wallter->proc~printvector program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/header.html"},{"title":"printMatrix – Fortran Program","text":"subroutine printMatrix(matriz, label) Imprime una matriz mas un texto como titulo. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: matriz character(len=*), intent(in) :: label Calls proc~~printmatrix~~CallsGraph proc~printmatrix printMatrix proc~header header proc~printmatrix->proc~header proc~linea linea proc~printmatrix->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~printmatrix~~CalledByGraph proc~printmatrix printMatrix program~wallter WALLTER program~wallter->proc~printmatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/printmatrix.html"},{"title":"printVector – Fortran Program","text":"subroutine printVector(f, label) Imprime un vector mas un texto como titulo Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: f character(len=*), intent(in) :: label Calls proc~~printvector~~CallsGraph proc~printvector printVector proc~header header proc~printvector->proc~header proc~linea linea proc~printvector->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~printvector~~CalledByGraph proc~printvector printVector program~wallter WALLTER program~wallter->proc~printvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/printvector.html"},{"title":"constructor – Fortran Program","text":"interface Interface para poder fijar las dimensiones de la matriz en la\n subroutine constructor Called By interface~~constructor~~CalledByGraph interface~constructor constructor program~wallter WALLTER program~wallter->interface~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. subroutine constructor(matriz, f, navier, n, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:), allocatable :: matriz sistema de ecuaciones real(kind=8), intent(inout), dimension(:), allocatable :: f vector terminos independientes real(kind=8), intent(inout), dimension(:,:), allocatable :: navier resultados analiticos integer, intent(out) :: n integer, intent(out) :: m","tags":"","loc":"interface/constructor.html"},{"title":"WALLTER – Fortran Program","text":"Programa para el calculo de flechas de una placa apoyada\n  en sus cantos con carga hidraulica hasta la mitad de su largo Calls program~~wallter~~CallsGraph program~wallter WALLTER proc~fcholesky fCholesky program~wallter->proc~fcholesky proc~printmatrix printMatrix program~wallter->proc~printmatrix proc~bienvenido bienvenido program~wallter->proc~bienvenido proc~printvector printVector program~wallter->proc~printvector proc~commandline commandLine program~wallter->proc~commandline proc~exportresultados exportResultados program~wallter->proc~exportresultados proc~linearsystem linearSystem program~wallter->proc~linearsystem interface~constructor constructor program~wallter->interface~constructor proc~header header proc~printmatrix->proc~header proc~linea linea proc~printmatrix->proc~linea proc~printvector->proc~header proc~printvector->proc~linea proc~header->proc~linea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Common Blocks unnamed Variables matriz f navier n m fMatriz forma orden resultsFile configFile asserts exists Interfaces constructor Subroutines header printMatrix printVector Common Blocks common Type Attributes Name Initial real :: resultsFile real :: configFile $(function () {\n       $('[data-toggle=\"popover\"]').popover()\n       }) Variables Type Attributes Name Initial real(kind=8), dimension(:,:), allocatable :: matriz sistema de ecuaciones real(kind=8), dimension(:), allocatable :: f vector terminos independientes real(kind=8), dimension(:,:), allocatable :: navier integer :: n numero de puntos para discretizar largo(n) y ancho(m) integer :: m numero de puntos para discretizar largo(n) y ancho(m) real(kind=8), dimension(:,:), allocatable :: fMatriz solucion en forma matricial integer, dimension(2) :: forma forma de la matriz solucion integer, dimension(2) :: orden = (/2, 1/) orden de los numeros al cambiar vector a matriz solucion character(len=50) :: resultsFile = './result/resultados.html' character(len=50) :: configFile = '' logical :: asserts = .FALSE. si se activa se imprimen los datos de la factorizacion logical :: exists Interfaces interface Interface para poder fijar las dimensiones de la matriz en la\n subroutine constructor subroutine constructor (matriz, f, navier, n, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:), allocatable :: matriz sistema de ecuaciones real(kind=8), intent(inout), dimension(:), allocatable :: f vector terminos independientes real(kind=8), intent(inout), dimension(:,:), allocatable :: navier resultados analiticos integer, intent(out) :: n integer, intent(out) :: m Subroutines subroutine header (label) Imprime una linea, un texto centrado y una línea.\n Creando como un titulo. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label subroutine printMatrix (matriz, label) Imprime una matriz mas un texto como titulo. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: matriz character(len=*), intent(in) :: label subroutine printVector (f, label) Imprime un vector mas un texto como titulo Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: f character(len=*), intent(in) :: label","tags":"","loc":"program/wallter.html"}]}